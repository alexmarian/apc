// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: expenses.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createExpense = `-- name: CreateExpense :one
INSERT INTO expenses (amount, description, destination, date,
                      month, year, document_ref, category_id, account_id)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id, amount, description, destination, date, month, year, category_id, account_id, created_at, updated_at, document_ref
`

type CreateExpenseParams struct {
	Amount      float64
	Description string
	Destination string
	Date        time.Time
	Month       int64
	Year        int64
	DocumentRef sql.NullString
	CategoryID  int64
	AccountID   int64
}

func (q *Queries) CreateExpense(ctx context.Context, arg CreateExpenseParams) (Expense, error) {
	row := q.db.QueryRowContext(ctx, createExpense,
		arg.Amount,
		arg.Description,
		arg.Destination,
		arg.Date,
		arg.Month,
		arg.Year,
		arg.DocumentRef,
		arg.CategoryID,
		arg.AccountID,
	)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Description,
		&i.Destination,
		&i.Date,
		&i.Month,
		&i.Year,
		&i.CategoryID,
		&i.AccountID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DocumentRef,
	)
	return i, err
}

const deleteExpense = `-- name: DeleteExpense :exec
DELETE
FROM expenses
WHERE id = ?
`

func (q *Queries) DeleteExpense(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteExpense, id)
	return err
}

const getDistinctDestinations = `-- name: GetDistinctDestinations :many
SELECT DISTINCT e.destination
FROM expenses e
         JOIN categories c ON e.category_id = c.id
WHERE c.association_id = ?
  AND e.destination != ''
ORDER BY e.destination
`

func (q *Queries) GetDistinctDestinations(ctx context.Context, associationID int64) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getDistinctDestinations, associationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var destination string
		if err := rows.Scan(&destination); err != nil {
			return nil, err
		}
		items = append(items, destination)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpenseWithAssociation = `-- name: GetExpenseWithAssociation :one
SELECT e.id, e.amount, e.description, e.destination, e.date, e.month, e.year, e.category_id, e.account_id, e.created_at, e.updated_at, e.document_ref
FROM expenses e
         JOIN categories c ON e.category_id = c.id
WHERE e.id = ?
  AND c.association_id = ? LIMIT 1
`

type GetExpenseWithAssociationParams struct {
	ID            int64
	AssociationID int64
}

func (q *Queries) GetExpenseWithAssociation(ctx context.Context, arg GetExpenseWithAssociationParams) (Expense, error) {
	row := q.db.QueryRowContext(ctx, getExpenseWithAssociation, arg.ID, arg.AssociationID)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Description,
		&i.Destination,
		&i.Date,
		&i.Month,
		&i.Year,
		&i.CategoryID,
		&i.AccountID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DocumentRef,
	)
	return i, err
}

const getExpenseWithJoins = `-- name: GetExpenseWithJoins :one
SELECT e.id,
       e.amount,
       e.description,
       e.destination,
       e.date,
       e.month,
       e.year,
       e.document_ref,
       e.category_id,
       e.account_id,
       c.type        as category_type,
       c.family      as category_family,
       c.name        as category_name,
       a.number      as account_number,
       a.description as account_name
FROM expenses e
         JOIN categories c ON e.category_id = c.id
         JOIN accounts a ON e.account_id = a.id
WHERE e.id = ?
  AND c.association_id = ? LIMIT 1
`

type GetExpenseWithJoinsParams struct {
	ID            int64
	AssociationID int64
}

type GetExpenseWithJoinsRow struct {
	ID             int64
	Amount         float64
	Description    string
	Destination    string
	Date           time.Time
	Month          int64
	Year           int64
	DocumentRef    sql.NullString
	CategoryID     int64
	AccountID      int64
	CategoryType   string
	CategoryFamily string
	CategoryName   string
	AccountNumber  string
	AccountName    string
}

func (q *Queries) GetExpenseWithJoins(ctx context.Context, arg GetExpenseWithJoinsParams) (GetExpenseWithJoinsRow, error) {
	row := q.db.QueryRowContext(ctx, getExpenseWithJoins, arg.ID, arg.AssociationID)
	var i GetExpenseWithJoinsRow
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Description,
		&i.Destination,
		&i.Date,
		&i.Month,
		&i.Year,
		&i.DocumentRef,
		&i.CategoryID,
		&i.AccountID,
		&i.CategoryType,
		&i.CategoryFamily,
		&i.CategoryName,
		&i.AccountNumber,
		&i.AccountName,
	)
	return i, err
}

const getExpensesByDateRange = `-- name: GetExpensesByDateRange :many
SELECT e.id,
       e.amount,
       e.description,
       e.destination,
       e.date,
       e.month,
       e.year,
       e.document_ref,
       e.category_id,
       e.account_id,
       c.type        as category_type,
       c.family      as category_family,
       c.name        as category_name,
       a.number      as account_number,
       a.description as account_name
FROM expenses e
         JOIN categories c ON e.category_id = c.id
         JOIN accounts a ON e.account_id = a.id
WHERE c.association_id = ?
  AND e.date > ?
  AND e.date < ?
ORDER BY e.date DESC
`

type GetExpensesByDateRangeParams struct {
	AssociationID int64
	Date          time.Time
	Date_2        time.Time
}

type GetExpensesByDateRangeRow struct {
	ID             int64
	Amount         float64
	Description    string
	Destination    string
	Date           time.Time
	Month          int64
	Year           int64
	DocumentRef    sql.NullString
	CategoryID     int64
	AccountID      int64
	CategoryType   string
	CategoryFamily string
	CategoryName   string
	AccountNumber  string
	AccountName    string
}

func (q *Queries) GetExpensesByDateRange(ctx context.Context, arg GetExpensesByDateRangeParams) ([]GetExpensesByDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getExpensesByDateRange, arg.AssociationID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpensesByDateRangeRow
	for rows.Next() {
		var i GetExpensesByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.Description,
			&i.Destination,
			&i.Date,
			&i.Month,
			&i.Year,
			&i.DocumentRef,
			&i.CategoryID,
			&i.AccountID,
			&i.CategoryType,
			&i.CategoryFamily,
			&i.CategoryName,
			&i.AccountNumber,
			&i.AccountName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpensesByDateRangeWithFilters = `-- name: GetExpensesByDateRangeWithFilters :many
SELECT e.id,
       e.amount,
       e.description,
       e.destination,
       e.date,
       e.month,
       e.year,
       e.document_ref,
       e.category_id,
       e.account_id,
       c.type        as category_type,
       c.family      as category_family,
       c.name        as category_name,
       a.number      as account_number,
       a.description as account_name
FROM expenses e
         JOIN categories c ON e.category_id = c.id
         JOIN accounts a ON e.account_id = a.id
WHERE c.association_id = ?
  AND e.date > ?
  AND e.date < ?
  AND (? = 0 OR e.category_id = ?) -- Filter by category_id if provided (non-zero)
  AND (? = '' OR c.type = ?)       -- Filter by category_type if provided (non-empty)
  AND (? = '' OR c.family = ?)     -- Filter by category_family if provided (non-empty)
ORDER BY e.date DESC
`

type GetExpensesByDateRangeWithFiltersParams struct {
	AssociationID int64
	Date          time.Time
	Date_2        time.Time
	Column4       interface{}
	CategoryID    int64
	Column6       interface{}
	Type          string
	Column8       interface{}
	Family        string
}

type GetExpensesByDateRangeWithFiltersRow struct {
	ID             int64
	Amount         float64
	Description    string
	Destination    string
	Date           time.Time
	Month          int64
	Year           int64
	DocumentRef    sql.NullString
	CategoryID     int64
	AccountID      int64
	CategoryType   string
	CategoryFamily string
	CategoryName   string
	AccountNumber  string
	AccountName    string
}

func (q *Queries) GetExpensesByDateRangeWithFilters(ctx context.Context, arg GetExpensesByDateRangeWithFiltersParams) ([]GetExpensesByDateRangeWithFiltersRow, error) {
	rows, err := q.db.QueryContext(ctx, getExpensesByDateRangeWithFilters,
		arg.AssociationID,
		arg.Date,
		arg.Date_2,
		arg.Column4,
		arg.CategoryID,
		arg.Column6,
		arg.Type,
		arg.Column8,
		arg.Family,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpensesByDateRangeWithFiltersRow
	for rows.Next() {
		var i GetExpensesByDateRangeWithFiltersRow
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.Description,
			&i.Destination,
			&i.Date,
			&i.Month,
			&i.Year,
			&i.DocumentRef,
			&i.CategoryID,
			&i.AccountID,
			&i.CategoryType,
			&i.CategoryFamily,
			&i.CategoryName,
			&i.AccountNumber,
			&i.AccountName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExpense = `-- name: UpdateExpense :one
UPDATE expenses
SET amount       = ?,
    description  = ?,
    destination  = ?,
    date         = ?,
    month        = ?,
    year         = ?,
    category_id  = ?,
    account_id   = ?,
    document_ref = ?,
    updated_at   = CURRENT_TIMESTAMP
WHERE id = ? RETURNING id, amount, description, destination, date, month, year, category_id, account_id, created_at, updated_at, document_ref
`

type UpdateExpenseParams struct {
	Amount      float64
	Description string
	Destination string
	Date        time.Time
	Month       int64
	Year        int64
	CategoryID  int64
	AccountID   int64
	DocumentRef sql.NullString
	ID          int64
}

func (q *Queries) UpdateExpense(ctx context.Context, arg UpdateExpenseParams) (Expense, error) {
	row := q.db.QueryRowContext(ctx, updateExpense,
		arg.Amount,
		arg.Description,
		arg.Destination,
		arg.Date,
		arg.Month,
		arg.Year,
		arg.CategoryID,
		arg.AccountID,
		arg.DocumentRef,
		arg.ID,
	)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Description,
		&i.Destination,
		&i.Date,
		&i.Month,
		&i.Year,
		&i.CategoryID,
		&i.AccountID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DocumentRef,
	)
	return i, err
}
