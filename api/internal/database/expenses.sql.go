// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: expenses.sql

package database

import (
	"context"
	"time"
)

const createExpense = `-- name: CreateExpense :one
INSERT INTO expenses (amount, description, destination, date,
                      month, year, category_id, account_id)
VALUES (?, ?, ?, ?, ?, ?, ?, ?) RETURNING id, amount, description, destination, date, month, year, category_id, account_id, created_at, updated_at
`

type CreateExpenseParams struct {
	Amount      float64
	Description string
	Destination string
	Date        time.Time
	Month       int64
	Year        int64
	CategoryID  int64
	AccountID   int64
}

func (q *Queries) CreateExpense(ctx context.Context, arg CreateExpenseParams) (Expense, error) {
	row := q.db.QueryRowContext(ctx, createExpense,
		arg.Amount,
		arg.Description,
		arg.Destination,
		arg.Date,
		arg.Month,
		arg.Year,
		arg.CategoryID,
		arg.AccountID,
	)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Description,
		&i.Destination,
		&i.Date,
		&i.Month,
		&i.Year,
		&i.CategoryID,
		&i.AccountID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteExpense = `-- name: DeleteExpense :exec
DELETE
FROM expenses
WHERE id = ?
`

func (q *Queries) DeleteExpense(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteExpense, id)
	return err
}

const getExpenseWithAssociation = `-- name: GetExpenseWithAssociation :one
SELECT e.id, e.amount, e.description, e.destination, e.date, e.month, e.year, e.category_id, e.account_id, e.created_at, e.updated_at
FROM expenses e
         JOIN categories c ON e.category_id = c.id
WHERE e.id = ?
  AND c.association_id = ? LIMIT 1
`

type GetExpenseWithAssociationParams struct {
	ID            int64
	AssociationID int64
}

func (q *Queries) GetExpenseWithAssociation(ctx context.Context, arg GetExpenseWithAssociationParams) (Expense, error) {
	row := q.db.QueryRowContext(ctx, getExpenseWithAssociation, arg.ID, arg.AssociationID)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Description,
		&i.Destination,
		&i.Date,
		&i.Month,
		&i.Year,
		&i.CategoryID,
		&i.AccountID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getExpensesByDateRange = `-- name: GetExpensesByDateRange :many
SELECT e.id,
       e.amount,
       e.description,
       e.destination,
       e.date,
       e.month,
       e.year,
       e.category_id,
       e.account_id,
       c.type        as category_type,
       c.family      as category_family,
       c.name        as category_name,
       a.number      as account_number,
       a.description as account_name
FROM expenses e
         JOIN categories c ON e.category_id = c.id
         JOIN accounts a ON e.account_id = a.id
WHERE c.association_id = ? AND e.date > ? AND e.date < ?
ORDER BY e.date DESC
`

type GetExpensesByDateRangeParams struct {
	AssociationID int64
	Date          time.Time
	Date_2        time.Time
}

type GetExpensesByDateRangeRow struct {
	ID             int64
	Amount         float64
	Description    string
	Destination    string
	Date           time.Time
	Month          int64
	Year           int64
	CategoryID     int64
	AccountID      int64
	CategoryType   string
	CategoryFamily string
	CategoryName   string
	AccountNumber  string
	AccountName    string
}

func (q *Queries) GetExpensesByDateRange(ctx context.Context, arg GetExpensesByDateRangeParams) ([]GetExpensesByDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getExpensesByDateRange, arg.AssociationID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpensesByDateRangeRow
	for rows.Next() {
		var i GetExpensesByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.Description,
			&i.Destination,
			&i.Date,
			&i.Month,
			&i.Year,
			&i.CategoryID,
			&i.AccountID,
			&i.CategoryType,
			&i.CategoryFamily,
			&i.CategoryName,
			&i.AccountNumber,
			&i.AccountName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExpense = `-- name: UpdateExpense :one
UPDATE expenses
SET amount      = ?,
    description = ?,
    destination = ?,
    date        = ?,
    month       = ?,
    year        = ?,
    category_id = ?,
    account_id  = ?,
    updated_at  = CURRENT_TIMESTAMP
WHERE id = ? RETURNING id, amount, description, destination, date, month, year, category_id, account_id, created_at, updated_at
`

type UpdateExpenseParams struct {
	Amount      float64
	Description string
	Destination string
	Date        time.Time
	Month       int64
	Year        int64
	CategoryID  int64
	AccountID   int64
	ID          int64
}

func (q *Queries) UpdateExpense(ctx context.Context, arg UpdateExpenseParams) (Expense, error) {
	row := q.db.QueryRowContext(ctx, updateExpense,
		arg.Amount,
		arg.Description,
		arg.Destination,
		arg.Date,
		arg.Month,
		arg.Year,
		arg.CategoryID,
		arg.AccountID,
		arg.ID,
	)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Description,
		&i.Destination,
		&i.Date,
		&i.Month,
		&i.Year,
		&i.CategoryID,
		&i.AccountID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
