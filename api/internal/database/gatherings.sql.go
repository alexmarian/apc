// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: gatherings.sql

package database

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const checkInParticipant = `-- name: CheckInParticipant :exec

UPDATE gathering_participants SET
                                  check_in_time = CURRENT_TIMESTAMP,
                                  updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND gathering_id = ?
`

type CheckInParticipantParams struct {
	ID          int64
	GatheringID int64
}

func (q *Queries) CheckInParticipant(ctx context.Context, arg CheckInParticipantParams) error {
	_, err := q.db.ExecContext(ctx, checkInParticipant, arg.ID, arg.GatheringID)
	return err
}

const createAuditLog = `-- name: CreateAuditLog :exec

INSERT INTO vote_audit_log (
    vote_id, action, performed_by, ip_address, user_agent, details
) VALUES (
             ?, ?, ?, ?, ?, ?
         )
`

type CreateAuditLogParams struct {
	VoteID      int64
	Action      string
	PerformedBy sql.NullString
	IpAddress   sql.NullString
	UserAgent   sql.NullString
	Details     sql.NullString
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) error {
	_, err := q.db.ExecContext(ctx, createAuditLog,
		arg.VoteID,
		arg.Action,
		arg.PerformedBy,
		arg.IpAddress,
		arg.UserAgent,
		arg.Details,
	)
	return err
}

const createGathering = `-- name: CreateGathering :one

INSERT INTO gatherings (
    association_id, title, description, intent, gathering_date,
    gathering_type, status, qualification_unit_types,
    qualification_floors, qualification_entrances,
    qualification_custom_rule
) VALUES (
             ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
         ) RETURNING id, association_id, title, description, intent, gathering_date, gathering_type, status, qualification_unit_types, qualification_floors, qualification_entrances, qualification_custom_rule, qualified_units_count, qualified_units_total_part, participating_units_count, participating_units_total_part, created_at, updated_at
`

type CreateGatheringParams struct {
	AssociationID           int64
	Title                   string
	Description             string
	Intent                  string
	GatheringDate           time.Time
	GatheringType           string
	Status                  string
	QualificationUnitTypes  sql.NullString
	QualificationFloors     sql.NullString
	QualificationEntrances  sql.NullString
	QualificationCustomRule sql.NullString
}

func (q *Queries) CreateGathering(ctx context.Context, arg CreateGatheringParams) (Gathering, error) {
	row := q.db.QueryRowContext(ctx, createGathering,
		arg.AssociationID,
		arg.Title,
		arg.Description,
		arg.Intent,
		arg.GatheringDate,
		arg.GatheringType,
		arg.Status,
		arg.QualificationUnitTypes,
		arg.QualificationFloors,
		arg.QualificationEntrances,
		arg.QualificationCustomRule,
	)
	var i Gathering
	err := row.Scan(
		&i.ID,
		&i.AssociationID,
		&i.Title,
		&i.Description,
		&i.Intent,
		&i.GatheringDate,
		&i.GatheringType,
		&i.Status,
		&i.QualificationUnitTypes,
		&i.QualificationFloors,
		&i.QualificationEntrances,
		&i.QualificationCustomRule,
		&i.QualifiedUnitsCount,
		&i.QualifiedUnitsTotalPart,
		&i.ParticipatingUnitsCount,
		&i.ParticipatingUnitsTotalPart,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createGatheringParticipant = `-- name: CreateGatheringParticipant :one

INSERT INTO gathering_participants (
    gathering_id, unit_id, participant_type, participant_name,
    participant_identification, owner_id, ownership_id,
    delegating_owner_id, delegation_document_ref,
    unit_number, unit_building_name, unit_voting_weight
) VALUES (
             ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
         ) RETURNING id, gathering_id, unit_id, participant_type, participant_name, participant_identification, owner_id, ownership_id, delegating_owner_id, delegation_document_ref, unit_number, unit_building_name, unit_voting_weight, check_in_time, voting_completed, created_at, updated_at
`

type CreateGatheringParticipantParams struct {
	GatheringID               int64
	UnitID                    int64
	ParticipantType           string
	ParticipantName           string
	ParticipantIdentification sql.NullString
	OwnerID                   sql.NullInt64
	OwnershipID               sql.NullInt64
	DelegatingOwnerID         sql.NullInt64
	DelegationDocumentRef     sql.NullString
	UnitNumber                string
	UnitBuildingName          string
	UnitVotingWeight          float64
}

func (q *Queries) CreateGatheringParticipant(ctx context.Context, arg CreateGatheringParticipantParams) (GatheringParticipant, error) {
	row := q.db.QueryRowContext(ctx, createGatheringParticipant,
		arg.GatheringID,
		arg.UnitID,
		arg.ParticipantType,
		arg.ParticipantName,
		arg.ParticipantIdentification,
		arg.OwnerID,
		arg.OwnershipID,
		arg.DelegatingOwnerID,
		arg.DelegationDocumentRef,
		arg.UnitNumber,
		arg.UnitBuildingName,
		arg.UnitVotingWeight,
	)
	var i GatheringParticipant
	err := row.Scan(
		&i.ID,
		&i.GatheringID,
		&i.UnitID,
		&i.ParticipantType,
		&i.ParticipantName,
		&i.ParticipantIdentification,
		&i.OwnerID,
		&i.OwnershipID,
		&i.DelegatingOwnerID,
		&i.DelegationDocumentRef,
		&i.UnitNumber,
		&i.UnitBuildingName,
		&i.UnitVotingWeight,
		&i.CheckInTime,
		&i.VotingCompleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createNotification = `-- name: CreateNotification :one

INSERT INTO gathering_notifications (
    gathering_id, owner_id, notification_type
) VALUES (
             ?, ?, ?
         ) ON CONFLICT (gathering_id, owner_id, notification_type)
DO UPDATE SET sent_at = CURRENT_TIMESTAMP
                  RETURNING id, gathering_id, owner_id, notification_type, sent_at, read_at, response_status
`

type CreateNotificationParams struct {
	GatheringID      int64
	OwnerID          int64
	NotificationType string
}

func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (GatheringNotification, error) {
	row := q.db.QueryRowContext(ctx, createNotification, arg.GatheringID, arg.OwnerID, arg.NotificationType)
	var i GatheringNotification
	err := row.Scan(
		&i.ID,
		&i.GatheringID,
		&i.OwnerID,
		&i.NotificationType,
		&i.SentAt,
		&i.ReadAt,
		&i.ResponseStatus,
	)
	return i, err
}

const createVote = `-- name: CreateVote :one

INSERT INTO votes (
    gathering_id, participant_id, voting_matter_id,
    voting_option_id, vote_value, vote_weight
) VALUES (
             ?, ?, ?, ?, ?, ?
         ) RETURNING id, gathering_id, participant_id, voting_matter_id, voting_option_id, vote_value, vote_weight, submitted_at
`

type CreateVoteParams struct {
	GatheringID    int64
	ParticipantID  int64
	VotingMatterID int64
	VotingOptionID sql.NullInt64
	VoteValue      sql.NullString
	VoteWeight     float64
}

func (q *Queries) CreateVote(ctx context.Context, arg CreateVoteParams) (Vote, error) {
	row := q.db.QueryRowContext(ctx, createVote,
		arg.GatheringID,
		arg.ParticipantID,
		arg.VotingMatterID,
		arg.VotingOptionID,
		arg.VoteValue,
		arg.VoteWeight,
	)
	var i Vote
	err := row.Scan(
		&i.ID,
		&i.GatheringID,
		&i.ParticipantID,
		&i.VotingMatterID,
		&i.VotingOptionID,
		&i.VoteValue,
		&i.VoteWeight,
		&i.SubmittedAt,
	)
	return i, err
}

const createVotingMatter = `-- name: CreateVotingMatter :one

INSERT INTO voting_matters (
    gathering_id, order_index, title, description, matter_type,
    voting_type, required_majority_type, required_majority_value,
    required_quorum, is_anonymous, show_results_during_voting,
    allow_abstention
) VALUES (
             ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
         ) RETURNING id, gathering_id, order_index, title, description, matter_type, voting_type, required_majority_type, required_majority_value, required_quorum, is_anonymous, show_results_during_voting, allow_abstention, is_locked, locked_at, created_at, updated_at
`

type CreateVotingMatterParams struct {
	GatheringID             int64
	OrderIndex              int64
	Title                   string
	Description             sql.NullString
	MatterType              string
	VotingType              string
	RequiredMajorityType    string
	RequiredMajorityValue   float64
	RequiredQuorum          sql.NullFloat64
	IsAnonymous             sql.NullBool
	ShowResultsDuringVoting sql.NullBool
	AllowAbstention         sql.NullBool
}

func (q *Queries) CreateVotingMatter(ctx context.Context, arg CreateVotingMatterParams) (VotingMatter, error) {
	row := q.db.QueryRowContext(ctx, createVotingMatter,
		arg.GatheringID,
		arg.OrderIndex,
		arg.Title,
		arg.Description,
		arg.MatterType,
		arg.VotingType,
		arg.RequiredMajorityType,
		arg.RequiredMajorityValue,
		arg.RequiredQuorum,
		arg.IsAnonymous,
		arg.ShowResultsDuringVoting,
		arg.AllowAbstention,
	)
	var i VotingMatter
	err := row.Scan(
		&i.ID,
		&i.GatheringID,
		&i.OrderIndex,
		&i.Title,
		&i.Description,
		&i.MatterType,
		&i.VotingType,
		&i.RequiredMajorityType,
		&i.RequiredMajorityValue,
		&i.RequiredQuorum,
		&i.IsAnonymous,
		&i.ShowResultsDuringVoting,
		&i.AllowAbstention,
		&i.IsLocked,
		&i.LockedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createVotingOption = `-- name: CreateVotingOption :one

INSERT INTO voting_options (
    voting_matter_id, option_text, order_index
) VALUES (
             ?, ?, ?
         ) RETURNING id, voting_matter_id, option_text, order_index, created_at
`

type CreateVotingOptionParams struct {
	VotingMatterID int64
	OptionText     string
	OrderIndex     int64
}

func (q *Queries) CreateVotingOption(ctx context.Context, arg CreateVotingOptionParams) (VotingOption, error) {
	row := q.db.QueryRowContext(ctx, createVotingOption, arg.VotingMatterID, arg.OptionText, arg.OrderIndex)
	var i VotingOption
	err := row.Scan(
		&i.ID,
		&i.VotingMatterID,
		&i.OptionText,
		&i.OrderIndex,
		&i.CreatedAt,
	)
	return i, err
}

const deleteVotingOptions = `-- name: DeleteVotingOptions :exec

DELETE  FROM voting_options
WHERE voting_matter_id = ?
`

func (q *Queries) DeleteVotingOptions(ctx context.Context, votingMatterID int64) error {
	_, err := q.db.ExecContext(ctx, deleteVotingOptions, votingMatterID)
	return err
}

const getGathering = `-- name: GetGathering :one

SELECT id, association_id, title, description, intent, gathering_date, gathering_type, status, qualification_unit_types, qualification_floors, qualification_entrances, qualification_custom_rule, qualified_units_count, qualified_units_total_part, participating_units_count, participating_units_total_part, created_at, updated_at FROM gatherings
WHERE id = ? AND association_id = ?
`

type GetGatheringParams struct {
	ID            int64
	AssociationID int64
}

func (q *Queries) GetGathering(ctx context.Context, arg GetGatheringParams) (Gathering, error) {
	row := q.db.QueryRowContext(ctx, getGathering, arg.ID, arg.AssociationID)
	var i Gathering
	err := row.Scan(
		&i.ID,
		&i.AssociationID,
		&i.Title,
		&i.Description,
		&i.Intent,
		&i.GatheringDate,
		&i.GatheringType,
		&i.Status,
		&i.QualificationUnitTypes,
		&i.QualificationFloors,
		&i.QualificationEntrances,
		&i.QualificationCustomRule,
		&i.QualifiedUnitsCount,
		&i.QualifiedUnitsTotalPart,
		&i.ParticipatingUnitsCount,
		&i.ParticipatingUnitsTotalPart,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGatheringParticipant = `-- name: GetGatheringParticipant :one

SELECT id, gathering_id, unit_id, participant_type, participant_name, participant_identification, owner_id, ownership_id, delegating_owner_id, delegation_document_ref, unit_number, unit_building_name, unit_voting_weight, check_in_time, voting_completed, created_at, updated_at FROM gathering_participants
WHERE id = ? AND gathering_id = ?
`

type GetGatheringParticipantParams struct {
	ID          int64
	GatheringID int64
}

func (q *Queries) GetGatheringParticipant(ctx context.Context, arg GetGatheringParticipantParams) (GatheringParticipant, error) {
	row := q.db.QueryRowContext(ctx, getGatheringParticipant, arg.ID, arg.GatheringID)
	var i GatheringParticipant
	err := row.Scan(
		&i.ID,
		&i.GatheringID,
		&i.UnitID,
		&i.ParticipantType,
		&i.ParticipantName,
		&i.ParticipantIdentification,
		&i.OwnerID,
		&i.OwnershipID,
		&i.DelegatingOwnerID,
		&i.DelegationDocumentRef,
		&i.UnitNumber,
		&i.UnitBuildingName,
		&i.UnitVotingWeight,
		&i.CheckInTime,
		&i.VotingCompleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGatheringParticipants = `-- name: GetGatheringParticipants :many
;

SELECT
    gp.id, gp.gathering_id, gp.unit_id, gp.participant_type, gp.participant_name, gp.participant_identification, gp.owner_id, gp.ownership_id, gp.delegating_owner_id, gp.delegation_document_ref, gp.unit_number, gp.unit_building_name, gp.unit_voting_weight, gp.check_in_time, gp.voting_completed, gp.created_at, gp.updated_at,
    o.name as owner_name,
    o.identification_number as owner_identification,
    delo.name as delegating_owner_name,
    u.unit_number,
    u.floor,
    u.entrance,
    b.name as building_name
FROM gathering_participants gp
         LEFT JOIN owners o ON gp.owner_id = o.id
         LEFT JOIN owners delo ON gp.delegating_owner_id = delo.id
         LEFT JOIN units u ON gp.unit_id = u.id
         LEFT JOIN buildings b ON u.building_id = b.id
WHERE gp.gathering_id = ?
ORDER BY gp.participant_name
`

type GetGatheringParticipantsRow struct {
	ID                        int64
	GatheringID               int64
	UnitID                    int64
	ParticipantType           string
	ParticipantName           string
	ParticipantIdentification sql.NullString
	OwnerID                   sql.NullInt64
	OwnershipID               sql.NullInt64
	DelegatingOwnerID         sql.NullInt64
	DelegationDocumentRef     sql.NullString
	UnitNumber                string
	UnitBuildingName          string
	UnitVotingWeight          float64
	CheckInTime               sql.NullTime
	VotingCompleted           sql.NullBool
	CreatedAt                 sql.NullTime
	UpdatedAt                 sql.NullTime
	OwnerName                 sql.NullString
	OwnerIdentification       sql.NullString
	DelegatingOwnerName       sql.NullString
	UnitNumber_2              sql.NullString
	Floor                     sql.NullInt64
	Entrance                  sql.NullInt64
	BuildingName              sql.NullString
}

func (q *Queries) GetGatheringParticipants(ctx context.Context, gatheringID int64) ([]GetGatheringParticipantsRow, error) {
	rows, err := q.db.QueryContext(ctx, getGatheringParticipants, gatheringID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGatheringParticipantsRow
	for rows.Next() {
		var i GetGatheringParticipantsRow
		if err := rows.Scan(
			&i.ID,
			&i.GatheringID,
			&i.UnitID,
			&i.ParticipantType,
			&i.ParticipantName,
			&i.ParticipantIdentification,
			&i.OwnerID,
			&i.OwnershipID,
			&i.DelegatingOwnerID,
			&i.DelegationDocumentRef,
			&i.UnitNumber,
			&i.UnitBuildingName,
			&i.UnitVotingWeight,
			&i.CheckInTime,
			&i.VotingCompleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerName,
			&i.OwnerIdentification,
			&i.DelegatingOwnerName,
			&i.UnitNumber_2,
			&i.Floor,
			&i.Entrance,
			&i.BuildingName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGatheringStats = `-- name: GetGatheringStats :one

SELECT
    g.id, g.association_id, g.title, g.description, g.intent, g.gathering_date, g.gathering_type, g.status, g.qualification_unit_types, g.qualification_floors, g.qualification_entrances, g.qualification_custom_rule, g.qualified_units_count, g.qualified_units_total_part, g.participating_units_count, g.participating_units_total_part, g.created_at, g.updated_at,
    COUNT(DISTINCT gp.id) as participant_count,
    COUNT(DISTINCT CASE WHEN gp.voting_completed THEN gp.id END) as completed_count,
    COALESCE(SUM(gp.unit_voting_weight), 0) as total_participating_weight
FROM gatherings g
         LEFT JOIN gathering_participants gp ON g.id = gp.gathering_id
WHERE g.id = ? AND g.association_id = ?
GROUP BY g.id
`

type GetGatheringStatsParams struct {
	ID            int64
	AssociationID int64
}

type GetGatheringStatsRow struct {
	ID                          int64
	AssociationID               int64
	Title                       string
	Description                 string
	Intent                      string
	GatheringDate               time.Time
	GatheringType               string
	Status                      string
	QualificationUnitTypes      sql.NullString
	QualificationFloors         sql.NullString
	QualificationEntrances      sql.NullString
	QualificationCustomRule     sql.NullString
	QualifiedUnitsCount         sql.NullInt64
	QualifiedUnitsTotalPart     sql.NullFloat64
	ParticipatingUnitsCount     sql.NullInt64
	ParticipatingUnitsTotalPart sql.NullFloat64
	CreatedAt                   sql.NullTime
	UpdatedAt                   sql.NullTime
	ParticipantCount            int64
	CompletedCount              int64
	TotalParticipatingWeight    interface{}
}

func (q *Queries) GetGatheringStats(ctx context.Context, arg GetGatheringStatsParams) (GetGatheringStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getGatheringStats, arg.ID, arg.AssociationID)
	var i GetGatheringStatsRow
	err := row.Scan(
		&i.ID,
		&i.AssociationID,
		&i.Title,
		&i.Description,
		&i.Intent,
		&i.GatheringDate,
		&i.GatheringType,
		&i.Status,
		&i.QualificationUnitTypes,
		&i.QualificationFloors,
		&i.QualificationEntrances,
		&i.QualificationCustomRule,
		&i.QualifiedUnitsCount,
		&i.QualifiedUnitsTotalPart,
		&i.ParticipatingUnitsCount,
		&i.ParticipatingUnitsTotalPart,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ParticipantCount,
		&i.CompletedCount,
		&i.TotalParticipatingWeight,
	)
	return i, err
}

const getGatherings = `-- name: GetGatherings :many
SELECT id, association_id, title, description, intent, gathering_date, gathering_type, status, qualification_unit_types, qualification_floors, qualification_entrances, qualification_custom_rule, qualified_units_count, qualified_units_total_part, participating_units_count, participating_units_total_part, created_at, updated_at FROM gatherings
WHERE association_id = ?
ORDER BY gathering_date DESC
`

func (q *Queries) GetGatherings(ctx context.Context, associationID int64) ([]Gathering, error) {
	rows, err := q.db.QueryContext(ctx, getGatherings, associationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Gathering
	for rows.Next() {
		var i Gathering
		if err := rows.Scan(
			&i.ID,
			&i.AssociationID,
			&i.Title,
			&i.Description,
			&i.Intent,
			&i.GatheringDate,
			&i.GatheringType,
			&i.Status,
			&i.QualificationUnitTypes,
			&i.QualificationFloors,
			&i.QualificationEntrances,
			&i.QualificationCustomRule,
			&i.QualifiedUnitsCount,
			&i.QualifiedUnitsTotalPart,
			&i.ParticipatingUnitsCount,
			&i.ParticipatingUnitsTotalPart,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNonParticipatingOwners = `-- name: GetNonParticipatingOwners :many

SELECT DISTINCT
    o.id,
    o.name,
    o.identification_number,
    o.contact_email,
    o.contact_phone,
    COUNT(DISTINCT own.unit_id) as units_count
FROM owners o
         JOIN ownerships own ON o.id = own.owner_id
         JOIN units u ON own.unit_id = u.id
         JOIN buildings b ON u.building_id = b.id
WHERE b.association_id = ?
  AND own.is_active = TRUE
  AND u.id IN (
    SELECT id FROM units u2
                       JOIN buildings b2 ON u2.building_id = b2.id
    WHERE b2.association_id = ?
      AND (false=? OR u2.unit_type in(/*SLICE:unit_types*/?))
      AND (false=? OR u2.floor in(/*SLICE:unit_floors*/?))
      AND (false=? OR u2.entrance in(/*SLICE:unit_entrances*/?))
)
  AND u.id NOT IN (
    SELECT unit_id FROM gathering_participants
    WHERE gathering_id = ?
)
GROUP BY o.id, o.name, o.identification_number, o.contact_email, o.contact_phone
ORDER BY o.name
`

type GetNonParticipatingOwnersParams struct {
	AssociationID   int64
	AssociationID_2 int64
	Column3         interface{}
	UnitTypes       []string
	Column5         interface{}
	UnitFloors      []int64
	Column7         interface{}
	UnitEntrances   []int64
	GatheringID     int64
}

type GetNonParticipatingOwnersRow struct {
	ID                   int64
	Name                 string
	IdentificationNumber string
	ContactEmail         string
	ContactPhone         string
	UnitsCount           int64
}

func (q *Queries) GetNonParticipatingOwners(ctx context.Context, arg GetNonParticipatingOwnersParams) ([]GetNonParticipatingOwnersRow, error) {
	query := getNonParticipatingOwners
	var queryParams []interface{}
	queryParams = append(queryParams, arg.AssociationID)
	queryParams = append(queryParams, arg.AssociationID_2)
	queryParams = append(queryParams, arg.Column3)
	if len(arg.UnitTypes) > 0 {
		for _, v := range arg.UnitTypes {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:unit_types*/?", strings.Repeat(",?", len(arg.UnitTypes))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:unit_types*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Column5)
	if len(arg.UnitFloors) > 0 {
		for _, v := range arg.UnitFloors {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:unit_floors*/?", strings.Repeat(",?", len(arg.UnitFloors))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:unit_floors*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Column7)
	if len(arg.UnitEntrances) > 0 {
		for _, v := range arg.UnitEntrances {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:unit_entrances*/?", strings.Repeat(",?", len(arg.UnitEntrances))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:unit_entrances*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.GatheringID)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNonParticipatingOwnersRow
	for rows.Next() {
		var i GetNonParticipatingOwnersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IdentificationNumber,
			&i.ContactEmail,
			&i.ContactPhone,
			&i.UnitsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotifications = `-- name: GetNotifications :many

SELECT id, gathering_id, owner_id, notification_type, sent_at, read_at, response_status FROM gathering_notifications
WHERE gathering_id = ?
ORDER BY sent_at DESC
`

func (q *Queries) GetNotifications(ctx context.Context, gatheringID int64) ([]GatheringNotification, error) {
	rows, err := q.db.QueryContext(ctx, getNotifications, gatheringID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GatheringNotification
	for rows.Next() {
		var i GatheringNotification
		if err := rows.Scan(
			&i.ID,
			&i.GatheringID,
			&i.OwnerID,
			&i.NotificationType,
			&i.SentAt,
			&i.ReadAt,
			&i.ResponseStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParticipantByUnit = `-- name: GetParticipantByUnit :one

SELECT id, gathering_id, unit_id, participant_type, participant_name, participant_identification, owner_id, ownership_id, delegating_owner_id, delegation_document_ref, unit_number, unit_building_name, unit_voting_weight, check_in_time, voting_completed, created_at, updated_at FROM gathering_participants
WHERE gathering_id = ? AND unit_id = ?
`

type GetParticipantByUnitParams struct {
	GatheringID int64
	UnitID      int64
}

func (q *Queries) GetParticipantByUnit(ctx context.Context, arg GetParticipantByUnitParams) (GatheringParticipant, error) {
	row := q.db.QueryRowContext(ctx, getParticipantByUnit, arg.GatheringID, arg.UnitID)
	var i GatheringParticipant
	err := row.Scan(
		&i.ID,
		&i.GatheringID,
		&i.UnitID,
		&i.ParticipantType,
		&i.ParticipantName,
		&i.ParticipantIdentification,
		&i.OwnerID,
		&i.OwnershipID,
		&i.DelegatingOwnerID,
		&i.DelegationDocumentRef,
		&i.UnitNumber,
		&i.UnitBuildingName,
		&i.UnitVotingWeight,
		&i.CheckInTime,
		&i.VotingCompleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getParticipantVotes = `-- name: GetParticipantVotes :many

SELECT
    v.id, v.gathering_id, v.participant_id, v.voting_matter_id, v.voting_option_id, v.vote_value, v.vote_weight, v.submitted_at,
    vm.title as matter_title,
    vo.option_text
FROM votes v
         JOIN voting_matters vm ON v.voting_matter_id = vm.id
         LEFT JOIN voting_options vo ON v.voting_option_id = vo.id
WHERE v.participant_id = ?
ORDER BY vm.order_index
`

type GetParticipantVotesRow struct {
	ID             int64
	GatheringID    int64
	ParticipantID  int64
	VotingMatterID int64
	VotingOptionID sql.NullInt64
	VoteValue      sql.NullString
	VoteWeight     float64
	SubmittedAt    sql.NullTime
	MatterTitle    string
	OptionText     sql.NullString
}

func (q *Queries) GetParticipantVotes(ctx context.Context, participantID int64) ([]GetParticipantVotesRow, error) {
	rows, err := q.db.QueryContext(ctx, getParticipantVotes, participantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetParticipantVotesRow
	for rows.Next() {
		var i GetParticipantVotesRow
		if err := rows.Scan(
			&i.ID,
			&i.GatheringID,
			&i.ParticipantID,
			&i.VotingMatterID,
			&i.VotingOptionID,
			&i.VoteValue,
			&i.VoteWeight,
			&i.SubmittedAt,
			&i.MatterTitle,
			&i.OptionText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQualifiedUnits = `-- name: GetQualifiedUnits :many

SELECT
    u.id,
    u.unit_number,
    u.cadastral_number,
    u.floor,
    u.entrance,
    u.area,
    u.part,
    u.unit_type,
    b.name as building_name,
    b.address as building_address
FROM units u
         JOIN buildings b ON u.building_id = b.id
WHERE b.association_id = ?
  AND (false=? OR u.unit_type in(/*SLICE:unit_types*/?))
  AND (false=? OR u.floor in(/*SLICE:unit_floors*/?))
  AND (false=? OR u.entrance in(/*SLICE:unit_entrances*/?))
ORDER BY b.name, u.unit_number
`

type GetQualifiedUnitsParams struct {
	AssociationID int64
	Column2       interface{}
	UnitTypes     []string
	Column4       interface{}
	UnitFloors    []int64
	Column6       interface{}
	UnitEntrances []int64
}

type GetQualifiedUnitsRow struct {
	ID              int64
	UnitNumber      string
	CadastralNumber string
	Floor           int64
	Entrance        int64
	Area            float64
	Part            float64
	UnitType        string
	BuildingName    string
	BuildingAddress string
}

func (q *Queries) GetQualifiedUnits(ctx context.Context, arg GetQualifiedUnitsParams) ([]GetQualifiedUnitsRow, error) {
	query := getQualifiedUnits
	var queryParams []interface{}
	queryParams = append(queryParams, arg.AssociationID)
	queryParams = append(queryParams, arg.Column2)
	if len(arg.UnitTypes) > 0 {
		for _, v := range arg.UnitTypes {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:unit_types*/?", strings.Repeat(",?", len(arg.UnitTypes))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:unit_types*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Column4)
	if len(arg.UnitFloors) > 0 {
		for _, v := range arg.UnitFloors {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:unit_floors*/?", strings.Repeat(",?", len(arg.UnitFloors))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:unit_floors*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Column6)
	if len(arg.UnitEntrances) > 0 {
		for _, v := range arg.UnitEntrances {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:unit_entrances*/?", strings.Repeat(",?", len(arg.UnitEntrances))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:unit_entrances*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQualifiedUnitsRow
	for rows.Next() {
		var i GetQualifiedUnitsRow
		if err := rows.Scan(
			&i.ID,
			&i.UnitNumber,
			&i.CadastralNumber,
			&i.Floor,
			&i.Entrance,
			&i.Area,
			&i.Part,
			&i.UnitType,
			&i.BuildingName,
			&i.BuildingAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVoteResults = `-- name: GetVoteResults :many

SELECT
    vm.id as matter_id,
    vm.title as matter_title,
    vm.required_majority_type,
    vm.required_majority_value,
    vm.is_anonymous,
    vo.id as option_id,
    vo.option_text,
    COALESCE(SUM(v.vote_weight), 0) as total_weight,
    COUNT(v.id) as vote_count
FROM voting_matters vm
         LEFT JOIN voting_options vo ON vm.id = vo.voting_matter_id
         LEFT JOIN votes v ON vo.id = v.voting_option_id
WHERE vm.gathering_id = ?
GROUP BY vm.id, vm.title, vm.required_majority_type,
         vm.required_majority_value, vm.is_anonymous, vo.id, vo.option_text
ORDER BY vm.order_index, vo.order_index
`

type GetVoteResultsRow struct {
	MatterID              int64
	MatterTitle           string
	RequiredMajorityType  string
	RequiredMajorityValue float64
	IsAnonymous           sql.NullBool
	OptionID              sql.NullInt64
	OptionText            sql.NullString
	TotalWeight           interface{}
	VoteCount             int64
}

func (q *Queries) GetVoteResults(ctx context.Context, gatheringID int64) ([]GetVoteResultsRow, error) {
	rows, err := q.db.QueryContext(ctx, getVoteResults, gatheringID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVoteResultsRow
	for rows.Next() {
		var i GetVoteResultsRow
		if err := rows.Scan(
			&i.MatterID,
			&i.MatterTitle,
			&i.RequiredMajorityType,
			&i.RequiredMajorityValue,
			&i.IsAnonymous,
			&i.OptionID,
			&i.OptionText,
			&i.TotalWeight,
			&i.VoteCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVotes = `-- name: GetVotes :many

SELECT
    v.id, v.gathering_id, v.participant_id, v.voting_matter_id, v.voting_option_id, v.vote_value, v.vote_weight, v.submitted_at,
    vm.title as matter_title,
    vo.option_text,
    gp.participant_name,
    gp.unit_number
FROM votes v
         JOIN voting_matters vm ON v.voting_matter_id = vm.id
         LEFT JOIN voting_options vo ON v.voting_option_id = vo.id
         JOIN gathering_participants gp ON v.participant_id = gp.id
WHERE v.gathering_id = ?
ORDER BY vm.order_index, v.submitted_at
`

type GetVotesRow struct {
	ID              int64
	GatheringID     int64
	ParticipantID   int64
	VotingMatterID  int64
	VotingOptionID  sql.NullInt64
	VoteValue       sql.NullString
	VoteWeight      float64
	SubmittedAt     sql.NullTime
	MatterTitle     string
	OptionText      string
	ParticipantName string
	UnitNumber      string
}

func (q *Queries) GetVotes(ctx context.Context, gatheringID int64) ([]GetVotesRow, error) {
	rows, err := q.db.QueryContext(ctx, getVotes, gatheringID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVotesRow
	for rows.Next() {
		var i GetVotesRow
		if err := rows.Scan(
			&i.ID,
			&i.GatheringID,
			&i.ParticipantID,
			&i.VotingMatterID,
			&i.VotingOptionID,
			&i.VoteValue,
			&i.VoteWeight,
			&i.SubmittedAt,
			&i.MatterTitle,
			&i.OptionText,
			&i.ParticipantName,
			&i.UnitNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVotesByMatter = `-- name: GetVotesByMatter :many

SELECT
    v.id, v.gathering_id, v.participant_id, v.voting_matter_id, v.voting_option_id, v.vote_value, v.vote_weight, v.submitted_at,
    vo.option_text,
    gp.participant_name,
    gp.unit_number,
    gp.participant_type
FROM votes v
         LEFT JOIN voting_options vo ON v.voting_option_id = vo.id
         JOIN gathering_participants gp ON v.participant_id = gp.id
WHERE v.voting_matter_id = ?
ORDER BY v.submitted_at
`

type GetVotesByMatterRow struct {
	ID              int64
	GatheringID     int64
	ParticipantID   int64
	VotingMatterID  int64
	VotingOptionID  sql.NullInt64
	VoteValue       sql.NullString
	VoteWeight      float64
	SubmittedAt     sql.NullTime
	OptionText      string
	ParticipantName string
	UnitNumber      string
	ParticipantType string
}

func (q *Queries) GetVotesByMatter(ctx context.Context, votingMatterID int64) ([]GetVotesByMatterRow, error) {
	rows, err := q.db.QueryContext(ctx, getVotesByMatter, votingMatterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVotesByMatterRow
	for rows.Next() {
		var i GetVotesByMatterRow
		if err := rows.Scan(
			&i.ID,
			&i.GatheringID,
			&i.ParticipantID,
			&i.VotingMatterID,
			&i.VotingOptionID,
			&i.VoteValue,
			&i.VoteWeight,
			&i.SubmittedAt,
			&i.OptionText,
			&i.ParticipantName,
			&i.UnitNumber,
			&i.ParticipantType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVotingMatter = `-- name: GetVotingMatter :one

SELECT id, gathering_id, order_index, title, description, matter_type, voting_type, required_majority_type, required_majority_value, required_quorum, is_anonymous, show_results_during_voting, allow_abstention, is_locked, locked_at, created_at, updated_at FROM voting_matters
WHERE id = ? AND gathering_id = ?
`

type GetVotingMatterParams struct {
	ID          int64
	GatheringID int64
}

func (q *Queries) GetVotingMatter(ctx context.Context, arg GetVotingMatterParams) (VotingMatter, error) {
	row := q.db.QueryRowContext(ctx, getVotingMatter, arg.ID, arg.GatheringID)
	var i VotingMatter
	err := row.Scan(
		&i.ID,
		&i.GatheringID,
		&i.OrderIndex,
		&i.Title,
		&i.Description,
		&i.MatterType,
		&i.VotingType,
		&i.RequiredMajorityType,
		&i.RequiredMajorityValue,
		&i.RequiredQuorum,
		&i.IsAnonymous,
		&i.ShowResultsDuringVoting,
		&i.AllowAbstention,
		&i.IsLocked,
		&i.LockedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVotingMatters = `-- name: GetVotingMatters :many

SELECT id, gathering_id, order_index, title, description, matter_type, voting_type, required_majority_type, required_majority_value, required_quorum, is_anonymous, show_results_during_voting, allow_abstention, is_locked, locked_at, created_at, updated_at FROM voting_matters
WHERE gathering_id = ?
ORDER BY order_index
`

func (q *Queries) GetVotingMatters(ctx context.Context, gatheringID int64) ([]VotingMatter, error) {
	rows, err := q.db.QueryContext(ctx, getVotingMatters, gatheringID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VotingMatter
	for rows.Next() {
		var i VotingMatter
		if err := rows.Scan(
			&i.ID,
			&i.GatheringID,
			&i.OrderIndex,
			&i.Title,
			&i.Description,
			&i.MatterType,
			&i.VotingType,
			&i.RequiredMajorityType,
			&i.RequiredMajorityValue,
			&i.RequiredQuorum,
			&i.IsAnonymous,
			&i.ShowResultsDuringVoting,
			&i.AllowAbstention,
			&i.IsLocked,
			&i.LockedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVotingOptions = `-- name: GetVotingOptions :many

SELECT id, voting_matter_id, option_text, order_index, created_at FROM voting_options
WHERE voting_matter_id = ?
ORDER BY order_index
`

func (q *Queries) GetVotingOptions(ctx context.Context, votingMatterID int64) ([]VotingOption, error) {
	rows, err := q.db.QueryContext(ctx, getVotingOptions, votingMatterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VotingOption
	for rows.Next() {
		var i VotingOption
		if err := rows.Scan(
			&i.ID,
			&i.VotingMatterID,
			&i.OptionText,
			&i.OrderIndex,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockVotingMatters = `-- name: LockVotingMatters :exec

UPDATE voting_matters SET
                          is_locked = TRUE,
                          locked_at = CURRENT_TIMESTAMP
WHERE gathering_id = ?
`

func (q *Queries) LockVotingMatters(ctx context.Context, gatheringID int64) error {
	_, err := q.db.ExecContext(ctx, lockVotingMatters, gatheringID)
	return err
}

const markVotingCompleted = `-- name: MarkVotingCompleted :exec

UPDATE gathering_participants SET
                                  voting_completed = TRUE,
                                  updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) MarkVotingCompleted(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markVotingCompleted, id)
	return err
}

const updateGathering = `-- name: UpdateGathering :one

UPDATE gatherings SET
                      title = ?,
                      description = ?,
                      intent = ?,
                      gathering_date = ?,
                      gathering_type = ?,
                      qualification_unit_types = ?,
                      qualification_floors = ?,
                      qualification_entrances = ?,
                      qualification_custom_rule = ?,
                      updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND association_id = ?
    RETURNING id, association_id, title, description, intent, gathering_date, gathering_type, status, qualification_unit_types, qualification_floors, qualification_entrances, qualification_custom_rule, qualified_units_count, qualified_units_total_part, participating_units_count, participating_units_total_part, created_at, updated_at
`

type UpdateGatheringParams struct {
	Title                   string
	Description             string
	Intent                  string
	GatheringDate           time.Time
	GatheringType           string
	QualificationUnitTypes  sql.NullString
	QualificationFloors     sql.NullString
	QualificationEntrances  sql.NullString
	QualificationCustomRule sql.NullString
	ID                      int64
	AssociationID           int64
}

func (q *Queries) UpdateGathering(ctx context.Context, arg UpdateGatheringParams) (Gathering, error) {
	row := q.db.QueryRowContext(ctx, updateGathering,
		arg.Title,
		arg.Description,
		arg.Intent,
		arg.GatheringDate,
		arg.GatheringType,
		arg.QualificationUnitTypes,
		arg.QualificationFloors,
		arg.QualificationEntrances,
		arg.QualificationCustomRule,
		arg.ID,
		arg.AssociationID,
	)
	var i Gathering
	err := row.Scan(
		&i.ID,
		&i.AssociationID,
		&i.Title,
		&i.Description,
		&i.Intent,
		&i.GatheringDate,
		&i.GatheringType,
		&i.Status,
		&i.QualificationUnitTypes,
		&i.QualificationFloors,
		&i.QualificationEntrances,
		&i.QualificationCustomRule,
		&i.QualifiedUnitsCount,
		&i.QualifiedUnitsTotalPart,
		&i.ParticipatingUnitsCount,
		&i.ParticipatingUnitsTotalPart,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateGatheringStats = `-- name: UpdateGatheringStats :exec
UPDATE gatherings SET
                      qualified_units_count = ?,
                      qualified_units_total_part = ?,
                      participating_units_count = ?,
                      participating_units_total_part = ?,
                      updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateGatheringStatsParams struct {
	QualifiedUnitsCount         sql.NullInt64
	QualifiedUnitsTotalPart     sql.NullFloat64
	ParticipatingUnitsCount     sql.NullInt64
	ParticipatingUnitsTotalPart sql.NullFloat64
	ID                          int64
}

func (q *Queries) UpdateGatheringStats(ctx context.Context, arg UpdateGatheringStatsParams) error {
	_, err := q.db.ExecContext(ctx, updateGatheringStats,
		arg.QualifiedUnitsCount,
		arg.QualifiedUnitsTotalPart,
		arg.ParticipatingUnitsCount,
		arg.ParticipatingUnitsTotalPart,
		arg.ID,
	)
	return err
}

const updateGatheringStatus = `-- name: UpdateGatheringStatus :one

UPDATE gatherings SET
                      status =?,
                      updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND association_id = ?
    RETURNING id, association_id, title, description, intent, gathering_date, gathering_type, status, qualification_unit_types, qualification_floors, qualification_entrances, qualification_custom_rule, qualified_units_count, qualified_units_total_part, participating_units_count, participating_units_total_part, created_at, updated_at
`

type UpdateGatheringStatusParams struct {
	Status        string
	ID            int64
	AssociationID int64
}

func (q *Queries) UpdateGatheringStatus(ctx context.Context, arg UpdateGatheringStatusParams) (Gathering, error) {
	row := q.db.QueryRowContext(ctx, updateGatheringStatus, arg.Status, arg.ID, arg.AssociationID)
	var i Gathering
	err := row.Scan(
		&i.ID,
		&i.AssociationID,
		&i.Title,
		&i.Description,
		&i.Intent,
		&i.GatheringDate,
		&i.GatheringType,
		&i.Status,
		&i.QualificationUnitTypes,
		&i.QualificationFloors,
		&i.QualificationEntrances,
		&i.QualificationCustomRule,
		&i.QualifiedUnitsCount,
		&i.QualifiedUnitsTotalPart,
		&i.ParticipatingUnitsCount,
		&i.ParticipatingUnitsTotalPart,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateNotificationStatus = `-- name: UpdateNotificationStatus :exec

UPDATE gathering_notifications SET
                                   read_at = CURRENT_TIMESTAMP,
                                   response_status = ?
WHERE gathering_id = ? AND owner_id = ? AND notification_type = ?
`

type UpdateNotificationStatusParams struct {
	ResponseStatus   sql.NullString
	GatheringID      int64
	OwnerID          int64
	NotificationType string
}

func (q *Queries) UpdateNotificationStatus(ctx context.Context, arg UpdateNotificationStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateNotificationStatus,
		arg.ResponseStatus,
		arg.GatheringID,
		arg.OwnerID,
		arg.NotificationType,
	)
	return err
}

const updateVotingMatter = `-- name: UpdateVotingMatter :one

UPDATE voting_matters SET
                          title = ?,
                          description = ?,
                          matter_type = ?,
                          voting_type = ?,
                          required_majority_type = ?,
                          required_majority_value = ?,
                          required_quorum = ?,
                          is_anonymous = ?,
                          show_results_during_voting = ?,
                          allow_abstention = ?,
                          updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND gathering_id = ? AND is_locked = FALSE
    RETURNING id, gathering_id, order_index, title, description, matter_type, voting_type, required_majority_type, required_majority_value, required_quorum, is_anonymous, show_results_during_voting, allow_abstention, is_locked, locked_at, created_at, updated_at
`

type UpdateVotingMatterParams struct {
	Title                   string
	Description             sql.NullString
	MatterType              string
	VotingType              string
	RequiredMajorityType    string
	RequiredMajorityValue   float64
	RequiredQuorum          sql.NullFloat64
	IsAnonymous             sql.NullBool
	ShowResultsDuringVoting sql.NullBool
	AllowAbstention         sql.NullBool
	ID                      int64
	GatheringID             int64
}

func (q *Queries) UpdateVotingMatter(ctx context.Context, arg UpdateVotingMatterParams) (VotingMatter, error) {
	row := q.db.QueryRowContext(ctx, updateVotingMatter,
		arg.Title,
		arg.Description,
		arg.MatterType,
		arg.VotingType,
		arg.RequiredMajorityType,
		arg.RequiredMajorityValue,
		arg.RequiredQuorum,
		arg.IsAnonymous,
		arg.ShowResultsDuringVoting,
		arg.AllowAbstention,
		arg.ID,
		arg.GatheringID,
	)
	var i VotingMatter
	err := row.Scan(
		&i.ID,
		&i.GatheringID,
		&i.OrderIndex,
		&i.Title,
		&i.Description,
		&i.MatterType,
		&i.VotingType,
		&i.RequiredMajorityType,
		&i.RequiredMajorityValue,
		&i.RequiredQuorum,
		&i.IsAnonymous,
		&i.ShowResultsDuringVoting,
		&i.AllowAbstention,
		&i.IsLocked,
		&i.LockedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
