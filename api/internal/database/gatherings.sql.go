// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: gatherings.sql

package database

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const assignUnitSlot = `-- name: AssignUnitSlot :one
UPDATE unit_slots
SET participant_id = ?,
    updated_at     = CURRENT_TIMESTAMP
WHERE gathering_id = ?
  AND participant_id IS NULL
  AND unit_id = ? RETURNING id, gathering_id, unit_id, participant_id, created_at, updated_at
`

type AssignUnitSlotParams struct {
	ParticipantID interface{}
	GatheringID   int64
	UnitID        int64
}

func (q *Queries) AssignUnitSlot(ctx context.Context, arg AssignUnitSlotParams) (UnitSlot, error) {
	row := q.db.QueryRowContext(ctx, assignUnitSlot, arg.ParticipantID, arg.GatheringID, arg.UnitID)
	var i UnitSlot
	err := row.Scan(
		&i.ID,
		&i.GatheringID,
		&i.UnitID,
		&i.ParticipantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const checkInParticipant = `-- name: CheckInParticipant :exec
UPDATE gathering_participants
SET check_in_time = CURRENT_TIMESTAMP,
    updated_at    = CURRENT_TIMESTAMP
WHERE id = ?
  AND gathering_id = ?
`

type CheckInParticipantParams struct {
	ID          int64
	GatheringID int64
}

func (q *Queries) CheckInParticipant(ctx context.Context, arg CheckInParticipantParams) error {
	_, err := q.db.ExecContext(ctx, checkInParticipant, arg.ID, arg.GatheringID)
	return err
}

const createAuditLog = `-- name: CreateAuditLog :exec
INSERT INTO voting_audit_log (gathering_id, entity_type, entity_id, action,
                              performed_by, ip_address, details)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateAuditLogParams struct {
	GatheringID int64
	EntityType  string
	EntityID    int64
	Action      string
	PerformedBy sql.NullString
	IpAddress   sql.NullString
	Details     sql.NullString
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) error {
	_, err := q.db.ExecContext(ctx, createAuditLog,
		arg.GatheringID,
		arg.EntityType,
		arg.EntityID,
		arg.Action,
		arg.PerformedBy,
		arg.IpAddress,
		arg.Details,
	)
	return err
}

const createBallot = `-- name: CreateBallot :one
INSERT INTO voting_ballots (gathering_id, participant_id, ballot_content, ballot_hash,
                            submitted_ip, submitted_user_agent)
VALUES (?, ?, ?, ?, ?, ?) RETURNING id, gathering_id, participant_id, ballot_content, ballot_hash, submitted_at, submitted_ip, submitted_user_agent, signature, signature_timestamp, signature_certificate, is_valid, invalidated_at, invalidation_reason
`

type CreateBallotParams struct {
	GatheringID        int64
	ParticipantID      int64
	BallotContent      string
	BallotHash         string
	SubmittedIp        sql.NullString
	SubmittedUserAgent sql.NullString
}

func (q *Queries) CreateBallot(ctx context.Context, arg CreateBallotParams) (VotingBallot, error) {
	row := q.db.QueryRowContext(ctx, createBallot,
		arg.GatheringID,
		arg.ParticipantID,
		arg.BallotContent,
		arg.BallotHash,
		arg.SubmittedIp,
		arg.SubmittedUserAgent,
	)
	var i VotingBallot
	err := row.Scan(
		&i.ID,
		&i.GatheringID,
		&i.ParticipantID,
		&i.BallotContent,
		&i.BallotHash,
		&i.SubmittedAt,
		&i.SubmittedIp,
		&i.SubmittedUserAgent,
		&i.Signature,
		&i.SignatureTimestamp,
		&i.SignatureCertificate,
		&i.IsValid,
		&i.InvalidatedAt,
		&i.InvalidationReason,
	)
	return i, err
}

const createGathering = `-- name: CreateGathering :one
INSERT INTO gatherings (association_id, title, description, intent, location, gathering_date,
                        gathering_type, status, qualification_unit_types,
                        qualification_floors, qualification_entrances,
                        qualification_custom_rule, qualified_units_count, qualified_units_total_part,
                        qualified_units_total_area)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id, association_id, title, description, intent, gathering_date, gathering_type, status, qualification_unit_types, qualification_floors, qualification_entrances, qualification_custom_rule, qualified_units_count, qualified_units_total_part, qualified_units_total_area, participating_units_count, participating_units_total_part, participating_units_total_area, created_at, updated_at, location
`

type CreateGatheringParams struct {
	AssociationID           int64
	Title                   string
	Description             string
	Intent                  string
	Location                string
	GatheringDate           time.Time
	GatheringType           string
	Status                  string
	QualificationUnitTypes  sql.NullString
	QualificationFloors     sql.NullString
	QualificationEntrances  sql.NullString
	QualificationCustomRule sql.NullString
	QualifiedUnitsCount     sql.NullInt64
	QualifiedUnitsTotalPart sql.NullFloat64
	QualifiedUnitsTotalArea sql.NullFloat64
}

func (q *Queries) CreateGathering(ctx context.Context, arg CreateGatheringParams) (Gathering, error) {
	row := q.db.QueryRowContext(ctx, createGathering,
		arg.AssociationID,
		arg.Title,
		arg.Description,
		arg.Intent,
		arg.Location,
		arg.GatheringDate,
		arg.GatheringType,
		arg.Status,
		arg.QualificationUnitTypes,
		arg.QualificationFloors,
		arg.QualificationEntrances,
		arg.QualificationCustomRule,
		arg.QualifiedUnitsCount,
		arg.QualifiedUnitsTotalPart,
		arg.QualifiedUnitsTotalArea,
	)
	var i Gathering
	err := row.Scan(
		&i.ID,
		&i.AssociationID,
		&i.Title,
		&i.Description,
		&i.Intent,
		&i.GatheringDate,
		&i.GatheringType,
		&i.Status,
		&i.QualificationUnitTypes,
		&i.QualificationFloors,
		&i.QualificationEntrances,
		&i.QualificationCustomRule,
		&i.QualifiedUnitsCount,
		&i.QualifiedUnitsTotalPart,
		&i.QualifiedUnitsTotalArea,
		&i.ParticipatingUnitsCount,
		&i.ParticipatingUnitsTotalPart,
		&i.ParticipatingUnitsTotalArea,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Location,
	)
	return i, err
}

const createGatheringParticipant = `-- name: CreateGatheringParticipant :one
INSERT INTO gathering_participants (gathering_id, participant_type, participant_name,
                                    participant_identification, owner_id, delegating_owner_id,
                                    delegation_document_ref, units_info, units_area, units_part)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id, gathering_id, participant_type, participant_name, participant_identification, owner_id, delegating_owner_id, delegation_document_ref, units_info, units_area, units_part, check_in_time, created_at, updated_at
`

type CreateGatheringParticipantParams struct {
	GatheringID               int64
	ParticipantType           string
	ParticipantName           string
	ParticipantIdentification sql.NullString
	OwnerID                   sql.NullInt64
	DelegatingOwnerID         sql.NullInt64
	DelegationDocumentRef     sql.NullString
	UnitsInfo                 string
	UnitsArea                 float64
	UnitsPart                 float64
}

func (q *Queries) CreateGatheringParticipant(ctx context.Context, arg CreateGatheringParticipantParams) (GatheringParticipant, error) {
	row := q.db.QueryRowContext(ctx, createGatheringParticipant,
		arg.GatheringID,
		arg.ParticipantType,
		arg.ParticipantName,
		arg.ParticipantIdentification,
		arg.OwnerID,
		arg.DelegatingOwnerID,
		arg.DelegationDocumentRef,
		arg.UnitsInfo,
		arg.UnitsArea,
		arg.UnitsPart,
	)
	var i GatheringParticipant
	err := row.Scan(
		&i.ID,
		&i.GatheringID,
		&i.ParticipantType,
		&i.ParticipantName,
		&i.ParticipantIdentification,
		&i.OwnerID,
		&i.DelegatingOwnerID,
		&i.DelegationDocumentRef,
		&i.UnitsInfo,
		&i.UnitsArea,
		&i.UnitsPart,
		&i.CheckInTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createNotification = `-- name: CreateNotification :one
INSERT INTO voting_notifications (gathering_id, owner_id, notification_type, sent_via)
VALUES (?, ?, ?, ?) ON CONFLICT (gathering_id, owner_id, notification_type)
DO
UPDATE SET
    sent_at = CURRENT_TIMESTAMP,
    sent_via = ?
    RETURNING id, gathering_id, owner_id, notification_type, sent_at, sent_via, read_at
`

type CreateNotificationParams struct {
	GatheringID      int64
	OwnerID          int64
	NotificationType string
	SentVia          sql.NullString
}

func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (VotingNotification, error) {
	row := q.db.QueryRowContext(ctx, createNotification,
		arg.GatheringID,
		arg.OwnerID,
		arg.NotificationType,
		arg.SentVia,
	)
	var i VotingNotification
	err := row.Scan(
		&i.ID,
		&i.GatheringID,
		&i.OwnerID,
		&i.NotificationType,
		&i.SentAt,
		&i.SentVia,
		&i.ReadAt,
	)
	return i, err
}

const createUnitSlot = `-- name: CreateUnitSlot :one
INSERT INTO unit_slots (gathering_id, unit_id)
VALUES (?, ?) RETURNING id, gathering_id, unit_id, participant_id, created_at, updated_at
`

type CreateUnitSlotParams struct {
	GatheringID int64
	UnitID      int64
}

func (q *Queries) CreateUnitSlot(ctx context.Context, arg CreateUnitSlotParams) (UnitSlot, error) {
	row := q.db.QueryRowContext(ctx, createUnitSlot, arg.GatheringID, arg.UnitID)
	var i UnitSlot
	err := row.Scan(
		&i.ID,
		&i.GatheringID,
		&i.UnitID,
		&i.ParticipantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createVotingMatter = `-- name: CreateVotingMatter :one
INSERT INTO voting_matters (gathering_id, order_index, title, description, matter_type, voting_config)
VALUES (?, ?, ?, ?, ?, ?) RETURNING id, gathering_id, order_index, title, description, matter_type, voting_config, created_at, updated_at
`

type CreateVotingMatterParams struct {
	GatheringID  int64
	OrderIndex   int64
	Title        string
	Description  sql.NullString
	MatterType   string
	VotingConfig string
}

func (q *Queries) CreateVotingMatter(ctx context.Context, arg CreateVotingMatterParams) (VotingMatter, error) {
	row := q.db.QueryRowContext(ctx, createVotingMatter,
		arg.GatheringID,
		arg.OrderIndex,
		arg.Title,
		arg.Description,
		arg.MatterType,
		arg.VotingConfig,
	)
	var i VotingMatter
	err := row.Scan(
		&i.ID,
		&i.GatheringID,
		&i.OrderIndex,
		&i.Title,
		&i.Description,
		&i.MatterType,
		&i.VotingConfig,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteGatheringParticipant = `-- name: DeleteGatheringParticipant :exec
DELETE
FROM gathering_participants
WHERE id = ?
  AND gathering_id = ?
`

type DeleteGatheringParticipantParams struct {
	ID          int64
	GatheringID int64
}

func (q *Queries) DeleteGatheringParticipant(ctx context.Context, arg DeleteGatheringParticipantParams) error {
	_, err := q.db.ExecContext(ctx, deleteGatheringParticipant, arg.ID, arg.GatheringID)
	return err
}

const deleteVotingMatter = `-- name: DeleteVotingMatter :exec
DELETE
FROM voting_matters
WHERE id = ?
  AND gathering_id = ?
`

type DeleteVotingMatterParams struct {
	ID          int64
	GatheringID int64
}

func (q *Queries) DeleteVotingMatter(ctx context.Context, arg DeleteVotingMatterParams) error {
	_, err := q.db.ExecContext(ctx, deleteVotingMatter, arg.ID, arg.GatheringID)
	return err
}

const getActiveOwnerUnitsForGathering = `-- name: GetActiveOwnerUnitsForGathering :many
SELECT o.id                    as owner_id,
       o.name                  as owner_name,
       o.normalized_name       as owner_normalized_name,
       o.identification_number as owner_identification,
       o.contact_email         as owner_contact_email,
       o.contact_phone         as owner_contact_phone,
       u.id                    as unit_id,
       u.cadastral_number,
       u.unit_number,
       u.area,
       u.part                  as voting_weight,
       u.unit_type,
       u.floor,
       u.entrance,
       b.id                    as building_id,
       b.name                  as building_name,
       b.address               as building_address,
       b.association_id,
       own.id                  as ownership_id
FROM owners o
         JOIN ownerships own ON o.id = own.owner_id
         JOIN units u ON own.unit_id = u.id
         JOIN buildings b ON u.building_id = b.id
WHERE own.is_active = TRUE
  AND own.is_voting = TRUE
  AND b.association_id = ?
  AND (false = ? OR u.unit_type IN (/*SLICE:unit_types*/?))
  AND (false = ? OR u.floor IN (/*SLICE:unit_floors*/?))
  AND (false = ? OR u.entrance IN (/*SLICE:unit_entrances*/?))
ORDER BY o.name, u.unit_number
`

type GetActiveOwnerUnitsForGatheringParams struct {
	AssociationID int64
	Column2       interface{}
	UnitTypes     []string
	Column4       interface{}
	UnitFloors    []int64
	Column6       interface{}
	UnitEntrances []int64
}

type GetActiveOwnerUnitsForGatheringRow struct {
	OwnerID             int64
	OwnerName           string
	OwnerNormalizedName string
	OwnerIdentification string
	OwnerContactEmail   string
	OwnerContactPhone   string
	UnitID              int64
	CadastralNumber     string
	UnitNumber          string
	Area                float64
	VotingWeight        float64
	UnitType            string
	Floor               int64
	Entrance            int64
	BuildingID          int64
	BuildingName        string
	BuildingAddress     string
	AssociationID       int64
	OwnershipID         int64
}

func (q *Queries) GetActiveOwnerUnitsForGathering(ctx context.Context, arg GetActiveOwnerUnitsForGatheringParams) ([]GetActiveOwnerUnitsForGatheringRow, error) {
	query := getActiveOwnerUnitsForGathering
	var queryParams []interface{}
	queryParams = append(queryParams, arg.AssociationID)
	queryParams = append(queryParams, arg.Column2)
	if len(arg.UnitTypes) > 0 {
		for _, v := range arg.UnitTypes {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:unit_types*/?", strings.Repeat(",?", len(arg.UnitTypes))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:unit_types*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Column4)
	if len(arg.UnitFloors) > 0 {
		for _, v := range arg.UnitFloors {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:unit_floors*/?", strings.Repeat(",?", len(arg.UnitFloors))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:unit_floors*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Column6)
	if len(arg.UnitEntrances) > 0 {
		for _, v := range arg.UnitEntrances {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:unit_entrances*/?", strings.Repeat(",?", len(arg.UnitEntrances))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:unit_entrances*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveOwnerUnitsForGatheringRow
	for rows.Next() {
		var i GetActiveOwnerUnitsForGatheringRow
		if err := rows.Scan(
			&i.OwnerID,
			&i.OwnerName,
			&i.OwnerNormalizedName,
			&i.OwnerIdentification,
			&i.OwnerContactEmail,
			&i.OwnerContactPhone,
			&i.UnitID,
			&i.CadastralNumber,
			&i.UnitNumber,
			&i.Area,
			&i.VotingWeight,
			&i.UnitType,
			&i.Floor,
			&i.Entrance,
			&i.BuildingID,
			&i.BuildingName,
			&i.BuildingAddress,
			&i.AssociationID,
			&i.OwnershipID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllVoteTallies = `-- name: GetAllVoteTallies :many
SELECT vt.id, vt.gathering_id, vt.voting_matter_id, vt.tally_data, vt.last_updated,
       vm.title as matter_title,
       vm.matter_type,
       vm.voting_config
FROM vote_tallies vt
         JOIN voting_matters vm ON vt.voting_matter_id = vm.id
WHERE vt.gathering_id = ?
ORDER BY vm.order_index
`

type GetAllVoteTalliesRow struct {
	ID             int64
	GatheringID    int64
	VotingMatterID int64
	TallyData      string
	LastUpdated    sql.NullTime
	MatterTitle    string
	MatterType     string
	VotingConfig   string
}

func (q *Queries) GetAllVoteTallies(ctx context.Context, gatheringID int64) ([]GetAllVoteTalliesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllVoteTallies, gatheringID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllVoteTalliesRow
	for rows.Next() {
		var i GetAllVoteTalliesRow
		if err := rows.Scan(
			&i.ID,
			&i.GatheringID,
			&i.VotingMatterID,
			&i.TallyData,
			&i.LastUpdated,
			&i.MatterTitle,
			&i.MatterType,
			&i.VotingConfig,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogs = `-- name: GetAuditLogs :many
SELECT id, gathering_id, entity_type, entity_id, "action", performed_by, performed_at, ip_address, details
FROM voting_audit_log
WHERE gathering_id = ?
ORDER BY performed_at DESC LIMIT ?
`

type GetAuditLogsParams struct {
	GatheringID int64
	Limit       int64
}

func (q *Queries) GetAuditLogs(ctx context.Context, arg GetAuditLogsParams) ([]VotingAuditLog, error) {
	rows, err := q.db.QueryContext(ctx, getAuditLogs, arg.GatheringID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VotingAuditLog
	for rows.Next() {
		var i VotingAuditLog
		if err := rows.Scan(
			&i.ID,
			&i.GatheringID,
			&i.EntityType,
			&i.EntityID,
			&i.Action,
			&i.PerformedBy,
			&i.PerformedAt,
			&i.IpAddress,
			&i.Details,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBallotByParticipant = `-- name: GetBallotByParticipant :one
SELECT id, gathering_id, participant_id, ballot_content, ballot_hash, submitted_at, submitted_ip, submitted_user_agent, signature, signature_timestamp, signature_certificate, is_valid, invalidated_at, invalidation_reason
FROM voting_ballots
WHERE gathering_id = ?
  AND participant_id = ?
`

type GetBallotByParticipantParams struct {
	GatheringID   int64
	ParticipantID int64
}

func (q *Queries) GetBallotByParticipant(ctx context.Context, arg GetBallotByParticipantParams) (VotingBallot, error) {
	row := q.db.QueryRowContext(ctx, getBallotByParticipant, arg.GatheringID, arg.ParticipantID)
	var i VotingBallot
	err := row.Scan(
		&i.ID,
		&i.GatheringID,
		&i.ParticipantID,
		&i.BallotContent,
		&i.BallotHash,
		&i.SubmittedAt,
		&i.SubmittedIp,
		&i.SubmittedUserAgent,
		&i.Signature,
		&i.SignatureTimestamp,
		&i.SignatureCertificate,
		&i.IsValid,
		&i.InvalidatedAt,
		&i.InvalidationReason,
	)
	return i, err
}

const getBallotsForGathering = `-- name: GetBallotsForGathering :many
SELECT vb.id, vb.gathering_id, vb.participant_id, vb.ballot_content, vb.ballot_hash, vb.submitted_at, vb.submitted_ip, vb.submitted_user_agent, vb.signature, vb.signature_timestamp, vb.signature_certificate, vb.is_valid, vb.invalidated_at, vb.invalidation_reason,
       gp.participant_name,
       gp.units_info,
       gp.units_area,
       gp.units_part
FROM voting_ballots vb
         JOIN gathering_participants gp ON vb.participant_id = gp.id
WHERE vb.gathering_id = ?
ORDER BY vb.submitted_at
`

type GetBallotsForGatheringRow struct {
	ID                   int64
	GatheringID          int64
	ParticipantID        int64
	BallotContent        string
	BallotHash           string
	SubmittedAt          sql.NullTime
	SubmittedIp          sql.NullString
	SubmittedUserAgent   sql.NullString
	Signature            sql.NullString
	SignatureTimestamp   sql.NullTime
	SignatureCertificate sql.NullString
	IsValid              sql.NullBool
	InvalidatedAt        sql.NullTime
	InvalidationReason   sql.NullString
	ParticipantName      string
	UnitsInfo            string
	UnitsArea            float64
	UnitsPart            float64
}

func (q *Queries) GetBallotsForGathering(ctx context.Context, gatheringID int64) ([]GetBallotsForGatheringRow, error) {
	rows, err := q.db.QueryContext(ctx, getBallotsForGathering, gatheringID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBallotsForGatheringRow
	for rows.Next() {
		var i GetBallotsForGatheringRow
		if err := rows.Scan(
			&i.ID,
			&i.GatheringID,
			&i.ParticipantID,
			&i.BallotContent,
			&i.BallotHash,
			&i.SubmittedAt,
			&i.SubmittedIp,
			&i.SubmittedUserAgent,
			&i.Signature,
			&i.SignatureTimestamp,
			&i.SignatureCertificate,
			&i.IsValid,
			&i.InvalidatedAt,
			&i.InvalidationReason,
			&i.ParticipantName,
			&i.UnitsInfo,
			&i.UnitsArea,
			&i.UnitsPart,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGathering = `-- name: GetGathering :one
SELECT id, association_id, title, description, intent, gathering_date, gathering_type, status, qualification_unit_types, qualification_floors, qualification_entrances, qualification_custom_rule, qualified_units_count, qualified_units_total_part, qualified_units_total_area, participating_units_count, participating_units_total_part, participating_units_total_area, created_at, updated_at, location
FROM gatherings
WHERE id = ?
  AND association_id = ?
`

type GetGatheringParams struct {
	ID            int64
	AssociationID int64
}

func (q *Queries) GetGathering(ctx context.Context, arg GetGatheringParams) (Gathering, error) {
	row := q.db.QueryRowContext(ctx, getGathering, arg.ID, arg.AssociationID)
	var i Gathering
	err := row.Scan(
		&i.ID,
		&i.AssociationID,
		&i.Title,
		&i.Description,
		&i.Intent,
		&i.GatheringDate,
		&i.GatheringType,
		&i.Status,
		&i.QualificationUnitTypes,
		&i.QualificationFloors,
		&i.QualificationEntrances,
		&i.QualificationCustomRule,
		&i.QualifiedUnitsCount,
		&i.QualifiedUnitsTotalPart,
		&i.QualifiedUnitsTotalArea,
		&i.ParticipatingUnitsCount,
		&i.ParticipatingUnitsTotalPart,
		&i.ParticipatingUnitsTotalArea,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Location,
	)
	return i, err
}

const getGatheringBallotCount = `-- name: GetGatheringBallotCount :one
SELECT COUNT(*) as count
FROM voting_ballots
WHERE gathering_id = ? AND is_valid = TRUE
`

func (q *Queries) GetGatheringBallotCount(ctx context.Context, gatheringID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getGatheringBallotCount, gatheringID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getGatheringParticipant = `-- name: GetGatheringParticipant :one
SELECT id, gathering_id, participant_type, participant_name, participant_identification, owner_id, delegating_owner_id, delegation_document_ref, units_info, units_area, units_part, check_in_time, created_at, updated_at
FROM gathering_participants
WHERE id = ?
  AND gathering_id = ?
`

type GetGatheringParticipantParams struct {
	ID          int64
	GatheringID int64
}

func (q *Queries) GetGatheringParticipant(ctx context.Context, arg GetGatheringParticipantParams) (GatheringParticipant, error) {
	row := q.db.QueryRowContext(ctx, getGatheringParticipant, arg.ID, arg.GatheringID)
	var i GatheringParticipant
	err := row.Scan(
		&i.ID,
		&i.GatheringID,
		&i.ParticipantType,
		&i.ParticipantName,
		&i.ParticipantIdentification,
		&i.OwnerID,
		&i.DelegatingOwnerID,
		&i.DelegationDocumentRef,
		&i.UnitsInfo,
		&i.UnitsArea,
		&i.UnitsPart,
		&i.CheckInTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGatheringParticipantCount = `-- name: GetGatheringParticipantCount :one
SELECT COUNT(*) as count
FROM gathering_participants
WHERE gathering_id = ?
`

func (q *Queries) GetGatheringParticipantCount(ctx context.Context, gatheringID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getGatheringParticipantCount, gatheringID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getGatheringParticipants = `-- name: GetGatheringParticipants :many
SELECT gp.id, gp.gathering_id, gp.participant_type, gp.participant_name, gp.participant_identification, gp.owner_id, gp.delegating_owner_id, gp.delegation_document_ref, gp.units_info, gp.units_area, gp.units_part, gp.check_in_time, gp.created_at, gp.updated_at,
       o.name                  as owner_name,
       o.identification_number as owner_identification,
       delo.name               as delegating_owner_name
FROM gathering_participants gp
         LEFT JOIN owners o ON gp.owner_id = o.id
         LEFT JOIN owners delo ON gp.delegating_owner_id = delo.id
WHERE gp.gathering_id = ?
ORDER BY gp.participant_name
`

type GetGatheringParticipantsRow struct {
	ID                        int64
	GatheringID               int64
	ParticipantType           string
	ParticipantName           string
	ParticipantIdentification sql.NullString
	OwnerID                   sql.NullInt64
	DelegatingOwnerID         sql.NullInt64
	DelegationDocumentRef     sql.NullString
	UnitsInfo                 string
	UnitsArea                 float64
	UnitsPart                 float64
	CheckInTime               sql.NullTime
	CreatedAt                 sql.NullTime
	UpdatedAt                 sql.NullTime
	OwnerName                 sql.NullString
	OwnerIdentification       sql.NullString
	DelegatingOwnerName       sql.NullString
}

func (q *Queries) GetGatheringParticipants(ctx context.Context, gatheringID int64) ([]GetGatheringParticipantsRow, error) {
	rows, err := q.db.QueryContext(ctx, getGatheringParticipants, gatheringID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGatheringParticipantsRow
	for rows.Next() {
		var i GetGatheringParticipantsRow
		if err := rows.Scan(
			&i.ID,
			&i.GatheringID,
			&i.ParticipantType,
			&i.ParticipantName,
			&i.ParticipantIdentification,
			&i.OwnerID,
			&i.DelegatingOwnerID,
			&i.DelegationDocumentRef,
			&i.UnitsInfo,
			&i.UnitsArea,
			&i.UnitsPart,
			&i.CheckInTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerName,
			&i.OwnerIdentification,
			&i.DelegatingOwnerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGatheringStats = `-- name: GetGatheringStats :one
SELECT id, association_id, title, description, intent, gathering_date, gathering_type, status, qualification_unit_types, qualification_floors, qualification_entrances, qualification_custom_rule, qualified_units_count, qualified_units_total_part, qualified_units_total_area, participating_units_count, participating_units_total_part, participating_units_total_area, created_at, updated_at, location
FROM gatherings
WHERE id = ?
  AND association_id = ?
`

type GetGatheringStatsParams struct {
	ID            int64
	AssociationID int64
}

func (q *Queries) GetGatheringStats(ctx context.Context, arg GetGatheringStatsParams) (Gathering, error) {
	row := q.db.QueryRowContext(ctx, getGatheringStats, arg.ID, arg.AssociationID)
	var i Gathering
	err := row.Scan(
		&i.ID,
		&i.AssociationID,
		&i.Title,
		&i.Description,
		&i.Intent,
		&i.GatheringDate,
		&i.GatheringType,
		&i.Status,
		&i.QualificationUnitTypes,
		&i.QualificationFloors,
		&i.QualificationEntrances,
		&i.QualificationCustomRule,
		&i.QualifiedUnitsCount,
		&i.QualifiedUnitsTotalPart,
		&i.QualifiedUnitsTotalArea,
		&i.ParticipatingUnitsCount,
		&i.ParticipatingUnitsTotalPart,
		&i.ParticipatingUnitsTotalArea,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Location,
	)
	return i, err
}

const getGatheringUnitSlots = `-- name: GetGatheringUnitSlots :many
SELECT us.id, us.gathering_id, us.unit_id, us.participant_id, us.created_at, us.updated_at,
       u.unit_number,
       u.floor,
       u.entrance,
       b.name as building_name
FROM unit_slots us
         JOIN units u ON us.unit_id = u.id
         JOIN buildings b ON u.building_id = b.id
WHERE us.gathering_id = ?
`

type GetGatheringUnitSlotsRow struct {
	ID            int64
	GatheringID   int64
	UnitID        int64
	ParticipantID interface{}
	CreatedAt     sql.NullTime
	UpdatedAt     sql.NullTime
	UnitNumber    string
	Floor         int64
	Entrance      int64
	BuildingName  string
}

func (q *Queries) GetGatheringUnitSlots(ctx context.Context, gatheringID int64) ([]GetGatheringUnitSlotsRow, error) {
	rows, err := q.db.QueryContext(ctx, getGatheringUnitSlots, gatheringID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGatheringUnitSlotsRow
	for rows.Next() {
		var i GetGatheringUnitSlotsRow
		if err := rows.Scan(
			&i.ID,
			&i.GatheringID,
			&i.UnitID,
			&i.ParticipantID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UnitNumber,
			&i.Floor,
			&i.Entrance,
			&i.BuildingName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGatherings = `-- name: GetGatherings :many
SELECT id, association_id, title, description, intent, gathering_date, gathering_type, status, qualification_unit_types, qualification_floors, qualification_entrances, qualification_custom_rule, qualified_units_count, qualified_units_total_part, qualified_units_total_area, participating_units_count, participating_units_total_part, participating_units_total_area, created_at, updated_at, location
FROM gatherings
WHERE association_id = ?
ORDER BY gathering_date DESC
`

func (q *Queries) GetGatherings(ctx context.Context, associationID int64) ([]Gathering, error) {
	rows, err := q.db.QueryContext(ctx, getGatherings, associationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Gathering
	for rows.Next() {
		var i Gathering
		if err := rows.Scan(
			&i.ID,
			&i.AssociationID,
			&i.Title,
			&i.Description,
			&i.Intent,
			&i.GatheringDate,
			&i.GatheringType,
			&i.Status,
			&i.QualificationUnitTypes,
			&i.QualificationFloors,
			&i.QualificationEntrances,
			&i.QualificationCustomRule,
			&i.QualifiedUnitsCount,
			&i.QualifiedUnitsTotalPart,
			&i.QualifiedUnitsTotalArea,
			&i.ParticipatingUnitsCount,
			&i.ParticipatingUnitsTotalPart,
			&i.ParticipatingUnitsTotalArea,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNonParticipatingOwners = `-- name: GetNonParticipatingOwners :many
SELECT DISTINCT o.id,
                o.name,
                o.identification_number,
                o.contact_email,
                o.contact_phone,
                COUNT(DISTINCT own.unit_id) as units_count
FROM owners o
         JOIN ownerships own ON o.id = own.owner_id
         JOIN units u ON own.unit_id = u.id
         JOIN buildings b ON u.building_id = b.id
WHERE b.association_id = ?
  AND own.is_active = TRUE
  AND u.id IN (SELECT u2.id
               FROM units u2
                        JOIN buildings b2 ON u2.building_id = b2.id
               WHERE b2.association_id = ?
                 AND (false = ? OR u2.unit_type IN (/*SLICE:unit_types*/?))
                 AND (false = ? OR u2.floor IN (/*SLICE:unit_floors*/?))
                 AND (false = ? OR u2.entrance IN (/*SLICE:unit_entrances*/?)))
  AND u.id NOT IN (SELECT unit_id
                   FROM gathering_participants
                   WHERE gathering_id = ?)
GROUP BY o.id, o.name, o.identification_number, o.contact_email, o.contact_phone
ORDER BY o.name
`

type GetNonParticipatingOwnersParams struct {
	AssociationID   int64
	AssociationID_2 int64
	Column3         interface{}
	UnitTypes       []string
	Column5         interface{}
	UnitFloors      []int64
	Column7         interface{}
	UnitEntrances   []int64
	GatheringID     int64
}

type GetNonParticipatingOwnersRow struct {
	ID                   int64
	Name                 string
	IdentificationNumber string
	ContactEmail         string
	ContactPhone         string
	UnitsCount           int64
}

func (q *Queries) GetNonParticipatingOwners(ctx context.Context, arg GetNonParticipatingOwnersParams) ([]GetNonParticipatingOwnersRow, error) {
	query := getNonParticipatingOwners
	var queryParams []interface{}
	queryParams = append(queryParams, arg.AssociationID)
	queryParams = append(queryParams, arg.AssociationID_2)
	queryParams = append(queryParams, arg.Column3)
	if len(arg.UnitTypes) > 0 {
		for _, v := range arg.UnitTypes {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:unit_types*/?", strings.Repeat(",?", len(arg.UnitTypes))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:unit_types*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Column5)
	if len(arg.UnitFloors) > 0 {
		for _, v := range arg.UnitFloors {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:unit_floors*/?", strings.Repeat(",?", len(arg.UnitFloors))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:unit_floors*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Column7)
	if len(arg.UnitEntrances) > 0 {
		for _, v := range arg.UnitEntrances {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:unit_entrances*/?", strings.Repeat(",?", len(arg.UnitEntrances))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:unit_entrances*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.GatheringID)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNonParticipatingOwnersRow
	for rows.Next() {
		var i GetNonParticipatingOwnersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IdentificationNumber,
			&i.ContactEmail,
			&i.ContactPhone,
			&i.UnitsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotifications = `-- name: GetNotifications :many
SELECT vn.id, vn.gathering_id, vn.owner_id, vn.notification_type, vn.sent_at, vn.sent_via, vn.read_at,
       o.name as owner_name,
       o.contact_email,
       o.contact_phone
FROM voting_notifications vn
         JOIN owners o ON vn.owner_id = o.id
WHERE vn.gathering_id = ?
ORDER BY vn.sent_at DESC
`

type GetNotificationsRow struct {
	ID               int64
	GatheringID      int64
	OwnerID          int64
	NotificationType string
	SentAt           sql.NullTime
	SentVia          sql.NullString
	ReadAt           sql.NullTime
	OwnerName        string
	ContactEmail     string
	ContactPhone     string
}

func (q *Queries) GetNotifications(ctx context.Context, gatheringID int64) ([]GetNotificationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getNotifications, gatheringID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNotificationsRow
	for rows.Next() {
		var i GetNotificationsRow
		if err := rows.Scan(
			&i.ID,
			&i.GatheringID,
			&i.OwnerID,
			&i.NotificationType,
			&i.SentAt,
			&i.SentVia,
			&i.ReadAt,
			&i.OwnerName,
			&i.ContactEmail,
			&i.ContactPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParticipatingUnitSlots = `-- name: GetParticipatingUnitSlots :many
SELECT us.id, us.gathering_id, us.unit_id, us.participant_id, us.created_at, us.updated_at,
       u.unit_number,
       u.floor,
       u.entrance,
       b.name as building_name
FROM unit_slots us
         JOIN units u ON us.unit_id = u.id
         JOIN buildings b ON u.building_id = b.id
WHERE us.gathering_id = ?
  AND us.participant_id = ?
ORDER BY u.unit_number
`

type GetParticipatingUnitSlotsParams struct {
	GatheringID   int64
	ParticipantID interface{}
}

type GetParticipatingUnitSlotsRow struct {
	ID            int64
	GatheringID   int64
	UnitID        int64
	ParticipantID interface{}
	CreatedAt     sql.NullTime
	UpdatedAt     sql.NullTime
	UnitNumber    string
	Floor         int64
	Entrance      int64
	BuildingName  string
}

func (q *Queries) GetParticipatingUnitSlots(ctx context.Context, arg GetParticipatingUnitSlotsParams) ([]GetParticipatingUnitSlotsRow, error) {
	rows, err := q.db.QueryContext(ctx, getParticipatingUnitSlots, arg.GatheringID, arg.ParticipantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetParticipatingUnitSlotsRow
	for rows.Next() {
		var i GetParticipatingUnitSlotsRow
		if err := rows.Scan(
			&i.ID,
			&i.GatheringID,
			&i.UnitID,
			&i.ParticipantID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UnitNumber,
			&i.Floor,
			&i.Entrance,
			&i.BuildingName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQualifiedUnits = `-- name: GetQualifiedUnits :many
SELECT u.id,
       u.unit_number,
       u.cadastral_number,
       u.floor,
       u.entrance,
       u.area,
       u.part,
       u.unit_type,
       b.name    as building_name,
       b.address as building_address
FROM units u
         JOIN buildings b ON u.building_id = b.id
WHERE b.association_id = ?
  AND (false = ? OR u.unit_type IN (/*SLICE:unit_types*/?))
  AND (false = ? OR u.floor IN (/*SLICE:unit_floors*/?))
  AND (false = ? OR u.entrance IN (/*SLICE:unit_entrances*/?))
ORDER BY b.name, u.unit_number
`

type GetQualifiedUnitsParams struct {
	AssociationID int64
	Column2       interface{}
	UnitTypes     []string
	Column4       interface{}
	UnitFloors    []int64
	Column6       interface{}
	UnitEntrances []int64
}

type GetQualifiedUnitsRow struct {
	ID              int64
	UnitNumber      string
	CadastralNumber string
	Floor           int64
	Entrance        int64
	Area            float64
	Part            float64
	UnitType        string
	BuildingName    string
	BuildingAddress string
}

func (q *Queries) GetQualifiedUnits(ctx context.Context, arg GetQualifiedUnitsParams) ([]GetQualifiedUnitsRow, error) {
	query := getQualifiedUnits
	var queryParams []interface{}
	queryParams = append(queryParams, arg.AssociationID)
	queryParams = append(queryParams, arg.Column2)
	if len(arg.UnitTypes) > 0 {
		for _, v := range arg.UnitTypes {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:unit_types*/?", strings.Repeat(",?", len(arg.UnitTypes))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:unit_types*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Column4)
	if len(arg.UnitFloors) > 0 {
		for _, v := range arg.UnitFloors {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:unit_floors*/?", strings.Repeat(",?", len(arg.UnitFloors))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:unit_floors*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Column6)
	if len(arg.UnitEntrances) > 0 {
		for _, v := range arg.UnitEntrances {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:unit_entrances*/?", strings.Repeat(",?", len(arg.UnitEntrances))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:unit_entrances*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQualifiedUnitsRow
	for rows.Next() {
		var i GetQualifiedUnitsRow
		if err := rows.Scan(
			&i.ID,
			&i.UnitNumber,
			&i.CadastralNumber,
			&i.Floor,
			&i.Entrance,
			&i.Area,
			&i.Part,
			&i.UnitType,
			&i.BuildingName,
			&i.BuildingAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnitSlot = `-- name: GetUnitSlot :one
SELECT us.id, us.gathering_id, us.unit_id, us.participant_id, us.created_at, us.updated_at,
       u.unit_number,
       u.floor,
       u.entrance,
       b.name as building_name
FROM unit_slots us
         JOIN units u ON us.unit_id = u.id
         JOIN buildings b ON u.building_id = b.id
WHERE us.gathering_id = ?
  AND us.id = ?
`

type GetUnitSlotParams struct {
	GatheringID int64
	ID          int64
}

type GetUnitSlotRow struct {
	ID            int64
	GatheringID   int64
	UnitID        int64
	ParticipantID interface{}
	CreatedAt     sql.NullTime
	UpdatedAt     sql.NullTime
	UnitNumber    string
	Floor         int64
	Entrance      int64
	BuildingName  string
}

func (q *Queries) GetUnitSlot(ctx context.Context, arg GetUnitSlotParams) (GetUnitSlotRow, error) {
	row := q.db.QueryRowContext(ctx, getUnitSlot, arg.GatheringID, arg.ID)
	var i GetUnitSlotRow
	err := row.Scan(
		&i.ID,
		&i.GatheringID,
		&i.UnitID,
		&i.ParticipantID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UnitNumber,
		&i.Floor,
		&i.Entrance,
		&i.BuildingName,
	)
	return i, err
}

const getVoteTally = `-- name: GetVoteTally :one
SELECT id, gathering_id, voting_matter_id, tally_data, last_updated
FROM vote_tallies
WHERE gathering_id = ?
  AND voting_matter_id = ?
`

type GetVoteTallyParams struct {
	GatheringID    int64
	VotingMatterID int64
}

func (q *Queries) GetVoteTally(ctx context.Context, arg GetVoteTallyParams) (VoteTally, error) {
	row := q.db.QueryRowContext(ctx, getVoteTally, arg.GatheringID, arg.VotingMatterID)
	var i VoteTally
	err := row.Scan(
		&i.ID,
		&i.GatheringID,
		&i.VotingMatterID,
		&i.TallyData,
		&i.LastUpdated,
	)
	return i, err
}

const getVotingMatter = `-- name: GetVotingMatter :one
SELECT id, gathering_id, order_index, title, description, matter_type, voting_config, created_at, updated_at
FROM voting_matters
WHERE id = ?
  AND gathering_id = ?
`

type GetVotingMatterParams struct {
	ID          int64
	GatheringID int64
}

func (q *Queries) GetVotingMatter(ctx context.Context, arg GetVotingMatterParams) (VotingMatter, error) {
	row := q.db.QueryRowContext(ctx, getVotingMatter, arg.ID, arg.GatheringID)
	var i VotingMatter
	err := row.Scan(
		&i.ID,
		&i.GatheringID,
		&i.OrderIndex,
		&i.Title,
		&i.Description,
		&i.MatterType,
		&i.VotingConfig,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVotingMatters = `-- name: GetVotingMatters :many
SELECT id, gathering_id, order_index, title, description, matter_type, voting_config, created_at, updated_at
FROM voting_matters
WHERE gathering_id = ?
ORDER BY order_index
`

func (q *Queries) GetVotingMatters(ctx context.Context, gatheringID int64) ([]VotingMatter, error) {
	rows, err := q.db.QueryContext(ctx, getVotingMatters, gatheringID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VotingMatter
	for rows.Next() {
		var i VotingMatter
		if err := rows.Scan(
			&i.ID,
			&i.GatheringID,
			&i.OrderIndex,
			&i.Title,
			&i.Description,
			&i.MatterType,
			&i.VotingConfig,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const invalidateBallot = `-- name: InvalidateBallot :exec
UPDATE voting_ballots
SET is_valid            = FALSE,
    invalidated_at      = CURRENT_TIMESTAMP,
    invalidation_reason = ?
WHERE id = ?
`

type InvalidateBallotParams struct {
	InvalidationReason sql.NullString
	ID                 int64
}

func (q *Queries) InvalidateBallot(ctx context.Context, arg InvalidateBallotParams) error {
	_, err := q.db.ExecContext(ctx, invalidateBallot, arg.InvalidationReason, arg.ID)
	return err
}

const removeUnitSlot = `-- name: RemoveUnitSlot :exec
DELETE
FROM unit_slots
WHERE gathering_id = ?
`

func (q *Queries) RemoveUnitSlot(ctx context.Context, gatheringID int64) error {
	_, err := q.db.ExecContext(ctx, removeUnitSlot, gatheringID)
	return err
}

const updateGathering = `-- name: UpdateGathering :one
UPDATE gatherings
SET title                          = ?,
    description                    = ?,
    intent                         = ?,
    location                       = ?,
    gathering_date                 = ?,
    gathering_type                 = ?,
    qualification_unit_types       = ?,
    qualification_floors           = ?,
    qualification_entrances        = ?,
    qualification_custom_rule      = ?,
    qualified_units_count          = ?,
    qualified_units_total_part     = ?,
    qualified_units_total_area     = ?,
    participating_units_count      = ?,
    participating_units_total_part = ?,
    participating_units_total_area = ?,
    updated_at                     = CURRENT_TIMESTAMP
WHERE id = ?
  AND association_id = ? RETURNING id, association_id, title, description, intent, gathering_date, gathering_type, status, qualification_unit_types, qualification_floors, qualification_entrances, qualification_custom_rule, qualified_units_count, qualified_units_total_part, qualified_units_total_area, participating_units_count, participating_units_total_part, participating_units_total_area, created_at, updated_at, location
`

type UpdateGatheringParams struct {
	Title                       string
	Description                 string
	Intent                      string
	Location                    string
	GatheringDate               time.Time
	GatheringType               string
	QualificationUnitTypes      sql.NullString
	QualificationFloors         sql.NullString
	QualificationEntrances      sql.NullString
	QualificationCustomRule     sql.NullString
	QualifiedUnitsCount         sql.NullInt64
	QualifiedUnitsTotalPart     sql.NullFloat64
	QualifiedUnitsTotalArea     sql.NullFloat64
	ParticipatingUnitsCount     sql.NullInt64
	ParticipatingUnitsTotalPart sql.NullFloat64
	ParticipatingUnitsTotalArea sql.NullFloat64
	ID                          int64
	AssociationID               int64
}

func (q *Queries) UpdateGathering(ctx context.Context, arg UpdateGatheringParams) (Gathering, error) {
	row := q.db.QueryRowContext(ctx, updateGathering,
		arg.Title,
		arg.Description,
		arg.Intent,
		arg.Location,
		arg.GatheringDate,
		arg.GatheringType,
		arg.QualificationUnitTypes,
		arg.QualificationFloors,
		arg.QualificationEntrances,
		arg.QualificationCustomRule,
		arg.QualifiedUnitsCount,
		arg.QualifiedUnitsTotalPart,
		arg.QualifiedUnitsTotalArea,
		arg.ParticipatingUnitsCount,
		arg.ParticipatingUnitsTotalPart,
		arg.ParticipatingUnitsTotalArea,
		arg.ID,
		arg.AssociationID,
	)
	var i Gathering
	err := row.Scan(
		&i.ID,
		&i.AssociationID,
		&i.Title,
		&i.Description,
		&i.Intent,
		&i.GatheringDate,
		&i.GatheringType,
		&i.Status,
		&i.QualificationUnitTypes,
		&i.QualificationFloors,
		&i.QualificationEntrances,
		&i.QualificationCustomRule,
		&i.QualifiedUnitsCount,
		&i.QualifiedUnitsTotalPart,
		&i.QualifiedUnitsTotalArea,
		&i.ParticipatingUnitsCount,
		&i.ParticipatingUnitsTotalPart,
		&i.ParticipatingUnitsTotalArea,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Location,
	)
	return i, err
}

const updateGatheringParticipantsUnits = `-- name: UpdateGatheringParticipantsUnits :one
UPDATE gathering_participants
SET units_info = ?,
    units_area = ?,
    units_part = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
  AND gathering_id = ? RETURNING id, gathering_id, participant_type, participant_name, participant_identification, owner_id, delegating_owner_id, delegation_document_ref, units_info, units_area, units_part, check_in_time, created_at, updated_at
`

type UpdateGatheringParticipantsUnitsParams struct {
	UnitsInfo   string
	UnitsArea   float64
	UnitsPart   float64
	ID          int64
	GatheringID int64
}

func (q *Queries) UpdateGatheringParticipantsUnits(ctx context.Context, arg UpdateGatheringParticipantsUnitsParams) (GatheringParticipant, error) {
	row := q.db.QueryRowContext(ctx, updateGatheringParticipantsUnits,
		arg.UnitsInfo,
		arg.UnitsArea,
		arg.UnitsPart,
		arg.ID,
		arg.GatheringID,
	)
	var i GatheringParticipant
	err := row.Scan(
		&i.ID,
		&i.GatheringID,
		&i.ParticipantType,
		&i.ParticipantName,
		&i.ParticipantIdentification,
		&i.OwnerID,
		&i.DelegatingOwnerID,
		&i.DelegationDocumentRef,
		&i.UnitsInfo,
		&i.UnitsArea,
		&i.UnitsPart,
		&i.CheckInTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateGatheringStats = `-- name: UpdateGatheringStats :exec
UPDATE gatherings
SET qualified_units_count      = ?,
    qualified_units_total_part = ?,
    qualified_units_total_area = ?,
    updated_at                 = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateGatheringStatsParams struct {
	QualifiedUnitsCount     sql.NullInt64
	QualifiedUnitsTotalPart sql.NullFloat64
	QualifiedUnitsTotalArea sql.NullFloat64
	ID                      int64
}

func (q *Queries) UpdateGatheringStats(ctx context.Context, arg UpdateGatheringStatsParams) error {
	_, err := q.db.ExecContext(ctx, updateGatheringStats,
		arg.QualifiedUnitsCount,
		arg.QualifiedUnitsTotalPart,
		arg.QualifiedUnitsTotalArea,
		arg.ID,
	)
	return err
}

const updateGatheringStatus = `-- name: UpdateGatheringStatus :one
UPDATE gatherings
SET status     = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
  AND association_id = ? RETURNING id, association_id, title, description, intent, gathering_date, gathering_type, status, qualification_unit_types, qualification_floors, qualification_entrances, qualification_custom_rule, qualified_units_count, qualified_units_total_part, qualified_units_total_area, participating_units_count, participating_units_total_part, participating_units_total_area, created_at, updated_at, location
`

type UpdateGatheringStatusParams struct {
	Status        string
	ID            int64
	AssociationID int64
}

func (q *Queries) UpdateGatheringStatus(ctx context.Context, arg UpdateGatheringStatusParams) (Gathering, error) {
	row := q.db.QueryRowContext(ctx, updateGatheringStatus, arg.Status, arg.ID, arg.AssociationID)
	var i Gathering
	err := row.Scan(
		&i.ID,
		&i.AssociationID,
		&i.Title,
		&i.Description,
		&i.Intent,
		&i.GatheringDate,
		&i.GatheringType,
		&i.Status,
		&i.QualificationUnitTypes,
		&i.QualificationFloors,
		&i.QualificationEntrances,
		&i.QualificationCustomRule,
		&i.QualifiedUnitsCount,
		&i.QualifiedUnitsTotalPart,
		&i.QualifiedUnitsTotalArea,
		&i.ParticipatingUnitsCount,
		&i.ParticipatingUnitsTotalPart,
		&i.ParticipatingUnitsTotalArea,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Location,
	)
	return i, err
}

const updateNotificationRead = `-- name: UpdateNotificationRead :exec
UPDATE voting_notifications
SET read_at = CURRENT_TIMESTAMP
WHERE gathering_id = ?
  AND owner_id = ?
  AND notification_type = ?
`

type UpdateNotificationReadParams struct {
	GatheringID      int64
	OwnerID          int64
	NotificationType string
}

func (q *Queries) UpdateNotificationRead(ctx context.Context, arg UpdateNotificationReadParams) error {
	_, err := q.db.ExecContext(ctx, updateNotificationRead, arg.GatheringID, arg.OwnerID, arg.NotificationType)
	return err
}

const updateParticipationStats = `-- name: UpdateParticipationStats :exec
UPDATE gatherings
SET participating_units_count      = ?,
    participating_units_total_part = ?,
    participating_units_total_area = ?,
    updated_at                     = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateParticipationStatsParams struct {
	ParticipatingUnitsCount     sql.NullInt64
	ParticipatingUnitsTotalPart sql.NullFloat64
	ParticipatingUnitsTotalArea sql.NullFloat64
	ID                          int64
}

func (q *Queries) UpdateParticipationStats(ctx context.Context, arg UpdateParticipationStatsParams) error {
	_, err := q.db.ExecContext(ctx, updateParticipationStats,
		arg.ParticipatingUnitsCount,
		arg.ParticipatingUnitsTotalPart,
		arg.ParticipatingUnitsTotalArea,
		arg.ID,
	)
	return err
}

const updateVotingMatter = `-- name: UpdateVotingMatter :one
UPDATE voting_matters
SET title         = ?,
    description   = ?,
    matter_type   = ?,
    voting_config = ?,
    updated_at    = CURRENT_TIMESTAMP
WHERE id = ?
  AND gathering_id = ? RETURNING id, gathering_id, order_index, title, description, matter_type, voting_config, created_at, updated_at
`

type UpdateVotingMatterParams struct {
	Title        string
	Description  sql.NullString
	MatterType   string
	VotingConfig string
	ID           int64
	GatheringID  int64
}

func (q *Queries) UpdateVotingMatter(ctx context.Context, arg UpdateVotingMatterParams) (VotingMatter, error) {
	row := q.db.QueryRowContext(ctx, updateVotingMatter,
		arg.Title,
		arg.Description,
		arg.MatterType,
		arg.VotingConfig,
		arg.ID,
		arg.GatheringID,
	)
	var i VotingMatter
	err := row.Scan(
		&i.ID,
		&i.GatheringID,
		&i.OrderIndex,
		&i.Title,
		&i.Description,
		&i.MatterType,
		&i.VotingConfig,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertVoteTally = `-- name: UpsertVoteTally :one
INSERT INTO vote_tallies (gathering_id, voting_matter_id, tally_data)
VALUES (?, ?, ?) ON CONFLICT (gathering_id, voting_matter_id)
DO
UPDATE SET
    tally_data = ?,
    last_updated = CURRENT_TIMESTAMP
    RETURNING id, gathering_id, voting_matter_id, tally_data, last_updated
`

type UpsertVoteTallyParams struct {
	GatheringID    int64
	VotingMatterID int64
	TallyData      string
}

func (q *Queries) UpsertVoteTally(ctx context.Context, arg UpsertVoteTallyParams) (VoteTally, error) {
	row := q.db.QueryRowContext(ctx, upsertVoteTally, arg.GatheringID, arg.VotingMatterID, arg.TallyData)
	var i VoteTally
	err := row.Scan(
		&i.ID,
		&i.GatheringID,
		&i.VotingMatterID,
		&i.TallyData,
		&i.LastUpdated,
	)
	return i, err
}
