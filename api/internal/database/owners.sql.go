// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: owners.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createOwner = `-- name: CreateOwner :one

INSERT INTO owners (name, normalized_name, identification_number,
                    contact_phone, contact_email, association_id)
VALUES (?, ?, ?, ?, ?, ?) RETURNING id, name, normalized_name, identification_number, contact_phone, contact_email, first_detected_at, association_id, created_at, updated_at
`

type CreateOwnerParams struct {
	Name                 string
	NormalizedName       string
	IdentificationNumber string
	ContactPhone         string
	ContactEmail         string
	AssociationID        int64
}

func (q *Queries) CreateOwner(ctx context.Context, arg CreateOwnerParams) (Owner, error) {
	row := q.db.QueryRowContext(ctx, createOwner,
		arg.Name,
		arg.NormalizedName,
		arg.IdentificationNumber,
		arg.ContactPhone,
		arg.ContactEmail,
		arg.AssociationID,
	)
	var i Owner
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NormalizedName,
		&i.IdentificationNumber,
		&i.ContactPhone,
		&i.ContactEmail,
		&i.FirstDetectedAt,
		&i.AssociationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOwnership = `-- name: CreateOwnership :one

INSERT INTO ownerships (unit_id, owner_id, association_id,
                        start_date, end_date, is_active, is_voting,
                        registration_document, registration_date)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id, unit_id, owner_id, association_id, start_date, end_date, is_active, registration_document, registration_date, created_at, updated_at, is_voting
`

type CreateOwnershipParams struct {
	UnitID               int64
	OwnerID              int64
	AssociationID        int64
	StartDate            sql.NullTime
	EndDate              sql.NullTime
	IsActive             bool
	IsVoting             bool
	RegistrationDocument string
	RegistrationDate     time.Time
}

func (q *Queries) CreateOwnership(ctx context.Context, arg CreateOwnershipParams) (Ownership, error) {
	row := q.db.QueryRowContext(ctx, createOwnership,
		arg.UnitID,
		arg.OwnerID,
		arg.AssociationID,
		arg.StartDate,
		arg.EndDate,
		arg.IsActive,
		arg.IsVoting,
		arg.RegistrationDocument,
		arg.RegistrationDate,
	)
	var i Ownership
	err := row.Scan(
		&i.ID,
		&i.UnitID,
		&i.OwnerID,
		&i.AssociationID,
		&i.StartDate,
		&i.EndDate,
		&i.IsActive,
		&i.RegistrationDocument,
		&i.RegistrationDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsVoting,
	)
	return i, err
}

const deactivateOwnership = `-- name: DeactivateOwnership :exec

UPDATE ownerships
SET is_active  = false,
    is_voting  = false,
    end_date   = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type DeactivateOwnershipParams struct {
	EndDate sql.NullTime
	ID      int64
}

func (q *Queries) DeactivateOwnership(ctx context.Context, arg DeactivateOwnershipParams) error {
	_, err := q.db.ExecContext(ctx, deactivateOwnership, arg.EndDate, arg.ID)
	return err
}

const getAssociationOwner = `-- name: GetAssociationOwner :one

SELECT id, name, normalized_name, identification_number, contact_phone, contact_email, first_detected_at, association_id, created_at, updated_at
FROM owners
WHERE owners.id = ?
  and owners.association_id = ?
`

type GetAssociationOwnerParams struct {
	ID            int64
	AssociationID int64
}

func (q *Queries) GetAssociationOwner(ctx context.Context, arg GetAssociationOwnerParams) (Owner, error) {
	row := q.db.QueryRowContext(ctx, getAssociationOwner, arg.ID, arg.AssociationID)
	var i Owner
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NormalizedName,
		&i.IdentificationNumber,
		&i.ContactPhone,
		&i.ContactEmail,
		&i.FirstDetectedAt,
		&i.AssociationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAssociationOwners = `-- name: GetAssociationOwners :many

SELECT id, name, normalized_name, identification_number, contact_phone, contact_email, first_detected_at, association_id, created_at, updated_at
FROM owners
WHERE owners.association_id = ?
`

func (q *Queries) GetAssociationOwners(ctx context.Context, associationID int64) ([]Owner, error) {
	rows, err := q.db.QueryContext(ctx, getAssociationOwners, associationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Owner
	for rows.Next() {
		var i Owner
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.NormalizedName,
			&i.IdentificationNumber,
			&i.ContactPhone,
			&i.ContactEmail,
			&i.FirstDetectedAt,
			&i.AssociationID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssociationVoters = `-- name: GetAssociationVoters :many

SELECT o.id                    as owner_id,
       o.name                  as owner_name,
       o.normalized_name       as owner_normalized_name,
       o.identification_number as owner_identification_number,
       o.contact_phone         as owner_contact_phone,
       o.contact_email         as owner_contact_email,
       o.first_detected_at     as owner_first_detected_at,
       o.created_at            as owner_created_at,
       o.updated_at            as owner_updated_at,
       u.id                    as unit_id,
       u.unit_number,
       u.area,
       u.part,
       u.unit_type,
       b.name                  as building_name,
       b.address               as building_address
FROM owners o
         JOIN ownerships os ON o.id = os.owner_id
         JOIN units u ON os.unit_id = u.id
         JOIN buildings b ON u.building_id = b.id
WHERE o.association_id = ?
  AND os.is_active = true
  AND os.is_voting = true
ORDER BY o.id, u.id
`

type GetAssociationVotersRow struct {
	OwnerID                   int64
	OwnerName                 string
	OwnerNormalizedName       string
	OwnerIdentificationNumber string
	OwnerContactPhone         string
	OwnerContactEmail         string
	OwnerFirstDetectedAt      sql.NullTime
	OwnerCreatedAt            sql.NullTime
	OwnerUpdatedAt            sql.NullTime
	UnitID                    int64
	UnitNumber                string
	Area                      float64
	Part                      float64
	UnitType                  string
	BuildingName              string
	BuildingAddress           string
}

func (q *Queries) GetAssociationVoters(ctx context.Context, associationID int64) ([]GetAssociationVotersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAssociationVoters, associationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAssociationVotersRow
	for rows.Next() {
		var i GetAssociationVotersRow
		if err := rows.Scan(
			&i.OwnerID,
			&i.OwnerName,
			&i.OwnerNormalizedName,
			&i.OwnerIdentificationNumber,
			&i.OwnerContactPhone,
			&i.OwnerContactEmail,
			&i.OwnerFirstDetectedAt,
			&i.OwnerCreatedAt,
			&i.OwnerUpdatedAt,
			&i.UnitID,
			&i.UnitNumber,
			&i.Area,
			&i.Part,
			&i.UnitType,
			&i.BuildingName,
			&i.BuildingAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnerById = `-- name: GetOwnerById :one

SELECT id, name, normalized_name, identification_number, contact_phone, contact_email, first_detected_at, association_id, created_at, updated_at
FROM owners
WHERE id = ? LIMIT 1
`

func (q *Queries) GetOwnerById(ctx context.Context, id int64) (Owner, error) {
	row := q.db.QueryRowContext(ctx, getOwnerById, id)
	var i Owner
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NormalizedName,
		&i.IdentificationNumber,
		&i.ContactPhone,
		&i.ContactEmail,
		&i.FirstDetectedAt,
		&i.AssociationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOwnerUnitsWithDetails = `-- name: GetOwnerUnitsWithDetails :many

SELECT u.id                     as unit_id,
       u.unit_number,
       u.area,
       u.part,
       u.unit_type,
       b.name                   as building_name,
       b.address                as building_address,
       o2.id                    as co_owner_id,
       o2.name                  as co_owner_name,
       o2.normalized_name       as co_owner_normalized_name,
       o2.identification_number as co_owner_identification_number,
       o2.contact_phone         as co_owner_contact_phone,
       o2.contact_email         as co_owner_contact_email
FROM ownerships o
         JOIN units u ON o.unit_id = u.id
         JOIN buildings b ON u.building_id = b.id
         LEFT JOIN ownerships o_co ON o.unit_id = o_co.unit_id AND o_co.is_active = true AND o_co.owner_id != o.owner_id
LEFT JOIN owners o2
ON o_co.owner_id = o2.id
WHERE o.owner_id = ? AND o.association_id = ? AND o.is_active = true
`

type GetOwnerUnitsWithDetailsParams struct {
	OwnerID       int64
	AssociationID int64
}

type GetOwnerUnitsWithDetailsRow struct {
	UnitID                      int64
	UnitNumber                  string
	Area                        float64
	Part                        float64
	UnitType                    string
	BuildingName                string
	BuildingAddress             string
	CoOwnerID                   sql.NullInt64
	CoOwnerName                 sql.NullString
	CoOwnerNormalizedName       sql.NullString
	CoOwnerIdentificationNumber sql.NullString
	CoOwnerContactPhone         sql.NullString
	CoOwnerContactEmail         sql.NullString
}

func (q *Queries) GetOwnerUnitsWithDetails(ctx context.Context, arg GetOwnerUnitsWithDetailsParams) ([]GetOwnerUnitsWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getOwnerUnitsWithDetails, arg.OwnerID, arg.AssociationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOwnerUnitsWithDetailsRow
	for rows.Next() {
		var i GetOwnerUnitsWithDetailsRow
		if err := rows.Scan(
			&i.UnitID,
			&i.UnitNumber,
			&i.Area,
			&i.Part,
			&i.UnitType,
			&i.BuildingName,
			&i.BuildingAddress,
			&i.CoOwnerID,
			&i.CoOwnerName,
			&i.CoOwnerNormalizedName,
			&i.CoOwnerIdentificationNumber,
			&i.CoOwnerContactPhone,
			&i.CoOwnerContactEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnerUnitsWithDetailsForReport = `-- name: GetOwnerUnitsWithDetailsForReport :many

SELECT o.id                     as owner_id,
       o.name                   as owner_name,
       o.normalized_name        as owner_normalized_name,
       o.identification_number  as owner_identification_number,
       o.contact_phone          as owner_contact_phone,
       o.contact_email          as owner_contact_email,
       o.first_detected_at      as owner_first_detected_at,
       o.created_at             as owner_created_at,
       o.updated_at             as owner_updated_at,
       u.id                     as unit_id,
       u.unit_number,
       u.area,
       u.part,
       u.unit_type,
       b.name                   as building_name,
       b.address                as building_address,
       o2.id                    as co_owner_id,
       o2.name                  as co_owner_name,
       o2.normalized_name       as co_owner_normalized_name,
       o2.identification_number as co_owner_identification_number,
       o2.contact_phone         as co_owner_contact_phone,
       o2.contact_email         as co_owner_contact_email
FROM owners o
         JOIN ownerships os ON o.id = os.owner_id
         JOIN units u ON os.unit_id = u.id
         JOIN buildings b ON u.building_id = b.id
         LEFT JOIN ownerships os2 ON os.unit_id = os2.unit_id AND os2.is_active = true AND os2.owner_id != o.id
LEFT JOIN owners o2
ON os2.owner_id = o2.id
WHERE
    o.association_id = ?
  AND
    os.is_active = true
  AND
    (? = 0
   OR o.id = ?) -- This filters by owner_id if provided, otherwise returns all
ORDER BY o.id, u.id
`

type GetOwnerUnitsWithDetailsForReportParams struct {
	AssociationID int64
	Column2       interface{}
	ID            int64
}

type GetOwnerUnitsWithDetailsForReportRow struct {
	OwnerID                     int64
	OwnerName                   string
	OwnerNormalizedName         string
	OwnerIdentificationNumber   string
	OwnerContactPhone           string
	OwnerContactEmail           string
	OwnerFirstDetectedAt        sql.NullTime
	OwnerCreatedAt              sql.NullTime
	OwnerUpdatedAt              sql.NullTime
	UnitID                      int64
	UnitNumber                  string
	Area                        float64
	Part                        float64
	UnitType                    string
	BuildingName                string
	BuildingAddress             string
	CoOwnerID                   sql.NullInt64
	CoOwnerName                 sql.NullString
	CoOwnerNormalizedName       sql.NullString
	CoOwnerIdentificationNumber sql.NullString
	CoOwnerContactPhone         sql.NullString
	CoOwnerContactEmail         sql.NullString
}

func (q *Queries) GetOwnerUnitsWithDetailsForReport(ctx context.Context, arg GetOwnerUnitsWithDetailsForReportParams) ([]GetOwnerUnitsWithDetailsForReportRow, error) {
	rows, err := q.db.QueryContext(ctx, getOwnerUnitsWithDetailsForReport, arg.AssociationID, arg.Column2, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOwnerUnitsWithDetailsForReportRow
	for rows.Next() {
		var i GetOwnerUnitsWithDetailsForReportRow
		if err := rows.Scan(
			&i.OwnerID,
			&i.OwnerName,
			&i.OwnerNormalizedName,
			&i.OwnerIdentificationNumber,
			&i.OwnerContactPhone,
			&i.OwnerContactEmail,
			&i.OwnerFirstDetectedAt,
			&i.OwnerCreatedAt,
			&i.OwnerUpdatedAt,
			&i.UnitID,
			&i.UnitNumber,
			&i.Area,
			&i.Part,
			&i.UnitType,
			&i.BuildingName,
			&i.BuildingAddress,
			&i.CoOwnerID,
			&i.CoOwnerName,
			&i.CoOwnerNormalizedName,
			&i.CoOwnerIdentificationNumber,
			&i.CoOwnerContactPhone,
			&i.CoOwnerContactEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnitOwners = `-- name: GetUnitOwners :many
SELECT owners.id,
       owners.name,
       owners.normalized_name,
       owners.identification_number,
       owners.contact_phone,
       owners.contact_email,
       owners.first_detected_at,
       owners.association_id,
       owners.created_at,
       owners.updated_at
FROM owners,
     ownerships
WHERE owners.id = ownerships.owner_id
  AND ownerships.unit_id = ?
  and ownerships.association_id = ?
`

type GetUnitOwnersParams struct {
	UnitID        int64
	AssociationID int64
}

func (q *Queries) GetUnitOwners(ctx context.Context, arg GetUnitOwnersParams) ([]Owner, error) {
	rows, err := q.db.QueryContext(ctx, getUnitOwners, arg.UnitID, arg.AssociationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Owner
	for rows.Next() {
		var i Owner
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.NormalizedName,
			&i.IdentificationNumber,
			&i.ContactPhone,
			&i.ContactEmail,
			&i.FirstDetectedAt,
			&i.AssociationID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAssociationOwner = `-- name: UpdateAssociationOwner :exec


UPDATE owners
SET name                  = ?,
    normalized_name       = ?,
    identification_number = ?,
    contact_phone         = ?,
    contact_email         = ?,
    updated_at            = datetime()
WHERE id = ?
  AND association_id = ?
`

type UpdateAssociationOwnerParams struct {
	Name                 string
	NormalizedName       string
	IdentificationNumber string
	ContactPhone         string
	ContactEmail         string
	ID                   int64
	AssociationID        int64
}

func (q *Queries) UpdateAssociationOwner(ctx context.Context, arg UpdateAssociationOwnerParams) error {
	_, err := q.db.ExecContext(ctx, updateAssociationOwner,
		arg.Name,
		arg.NormalizedName,
		arg.IdentificationNumber,
		arg.ContactPhone,
		arg.ContactEmail,
		arg.ID,
		arg.AssociationID,
	)
	return err
}
